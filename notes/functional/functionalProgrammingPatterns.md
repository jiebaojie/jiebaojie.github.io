---
layout: post
notes: true
subtitle: "Functional Programming Patterns in Scala and Clojure (Write Lean Programs for the JVM)"
comments: false
author: "[美] Michael Bevilacqua-Linn 著 （赵震一 译）"
date: 2016-09-27 12:00:00

---


![](/img/notes/functional/functionalProgrammingPatterns/functional_programming_patterns.jpeg)

*   目录
{:toc }

# 第1章 模式和函数式编程

模式和函数式编程可以通过两种方式结合在一起。

*   对于很多面向对象的设计模式来说，采用函数式编程来实现更简单。
    *   函数式语言为我们提供了更加简单的方式来完成一些计算的传递，而无需创建新的类。
    *   使用表达式（expression）而非语句（statement）可以让我们消除那些额外的变量。
    *   声明性是很多函数式解决方案所拥有的一个特质，这种特质可以让我们在一行代码中完成原本在命令式语言中需要五行代码才能完成的工作。我们甚至可以用函数式语言特性的简单应用来替代某些面向对象模式。
*   函数式的世界也有一套它自己的有用的模式。这些模式专注于编写避免可变性且偏好声明性风格的代码，可以帮助我们编写出更加简单且更易维护的代码。

## 1.1 什么是函数式编程

函数式编程特征：

*   *拥有头等(first-class)函数*：头等函数是指那些可以被传递、动态创建并可以存储于数据结构中的函数。
*   *偏好纯函数(pure function)*：纯函数是指那些没有副作用的函数。副作用是指函数的某种行为，这种行为会对函数之外的状态进行修改。
*   *组合函数*：函数式编程支持通过将函数进行组合来自底向上地构建程序。
*   *使用表达式*：函数式编程偏爱表达式胜于语句。表达式会产生值，而语句则不然，它的存在仅仅是为了控制程序的执行流程。
*   *使用不变性*：因为函数式编程偏好纯函数，而纯函数不会修改数据，它同时又大量使用了不可变数据。所以程序不会去修改一个已经存在的数据结构，而是有效地创建一份心数据。
*   *转换数据而非修改数据*：函数式编程使用函数来转换数据。

## 1.2 模式词汇表

# 第2章 TinyWeb：让模式协同工作

## 2.1 TinyWeb简介

## 2.2 采用Java来编写TinyWeb

    HttpResponse testResponse = HttpResponse.Builder.newBuilder()
        .responseCode(200)
        .body("responseBody")
        .build();

**不可变性：不只是函数式程序员的专享**

## 2.3 采用Scala来编写TinyWeb

## 2.4 采用Clojure来编写TinyWeb

# 第3章 替代面向对象模式

## 模式1 替代函数式接口

**目的**：将一些程序逻辑进行封装，以支持对这些程序逻辑的传递，以及将其存储于数据结构中，通常还可以将这段封装后的程序逻辑作为任何其他头等的程序构造元素来处理。

在函数式语言中，函数都是高阶的：它们可以作为其他函数的结果返回，也可以作为其他函数的入参。

高阶函数相对于函数式接口的一个优势：你不需要为每一种函数式接口都定义新的类型，因为现有的函数类型就可以满足你的需要。

## 模式2 替代承载状态的函数式接口

**目的**：将一些状态与程序逻辑封装到一起，以支持对这些程序逻辑的传递，以及将其存储于数据结构之中，通常还可以将这段封装后的程序逻辑作为任何其他头等的程序构造元素来处理。

凭借着JSR 335（即Lambda表达式）的旗号，闭包和高阶函数成为了即将到来的Java 8中的主要功能特性之一。

## 模式3 替代命令模式

**目的**：将方法调用转变成一个对象，并在集中的地方运行该对象，以保持对调用的跟踪，从而方便我们对调用进行撤销、记录以及重做。

*   Command类本身是一个通常承载了状态的函数式接口，所以可以用闭包来替代Command类。
*   用一个简单的函数来替代调用者执行命令，我们称它为执行函数。
*   最后，将创建一个函数生成器，它负责创建我们的命令，让创建过程变得简单且一致。

## 模式4 替代生成器模式来获得不可变对象

**目的**：创建不可变对象时，我们通常会采用一种友好的语法来为对象设置属性——因为我们无法在创建完成之后再对其进行修改。同时，我们也需要一种简单的方式基于现有对象来创建新的对象，并为新对象的一些属性设置新值。

## 模式5：替代迭代器模式

**目的**：在无需对序列中的元素进行索引的情况下，有序地对元素进行迭代访问。

## 模式6：替代模板方法模式

**目的**：指定算法的大致轮廓，并让调用者完成对某些细节的插入。

**替代方案**：不再使用类来实现子步骤方法，转而采用高阶函数；同时，也不再依赖于子类继承的方式，而是依赖于函数的组合。我们将把所有的子操作传入一个函数生成器（Function Builder），该生成器会返回一个执行所有操作的新函数。

模板方法模式的函数式替代方案实现了与原有模式一样的目的，但是它们在操作上有些不同。我们不再使用子类型来实现特定的子操作，而是选择使用函数式的组合和高阶函数。

## 模式7：替代策略模式

**目的**：以抽象的形式来定义算法，使其可以由不同的方式来实现。同时允许将算法注入到客户端，便于被多个不同的客户端所使用。

策略模式和模板方法模式都服务于相似的目的。它们都可以向一个较大规模的框架或算法注入一些自定义代码。不同的是策略模式采用了组合，而模板方法模式采用的是继承。而我们都是基于函数式组合来代替了这两种模式。

## 模式8 替代空对象

**目的**：为了避免将空检查的逻辑散落在代码中，我们将专门用于处理null引用的措施封装进了一个起代理作用的空对象中。

## 模式9 替代装饰器模式

**目的**：将行为添加到单独的对象上，而不是对象所属的整个类上，让我们可以对一个既有的类的行为进行更改。

**函数式替代方案**：装饰器模式的本质是采用一个新的类来对既有类进行包装，以便该新的类可以对既有类的行为进行调整。在函数式的世界里，一种简单的替代方案就是创建一个高阶函数，该高阶函数以既有的函数作为入参，然后返回一个新的经过包装的函数。

## 模式10 替代访问者模式

**目的**：以某种方式对在某个数据结构上执行的行为进行封装，进而在不修改原有数据结构的情况下为该数据结构添加新的操作。

**访问者模式**：访问者模式打破了原有的面向对象的约束，即容易为数据类型添加新的实现，却难以为其添加新的操作。