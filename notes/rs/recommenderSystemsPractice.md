---
layout: post
notes: true
subtitle: "推荐系统实践"
comments: false
author: "项亮"
date: 2018-01-29 00:00:00

---

![](/img/notes/rs/recommenderSystemsPractice/recommender_systems_practice.jpg)

*   目录
{:toc }

# 第1章 好的推荐系统

## 1.1 什么是推荐系统

推荐系统的任务就是联系用户和信息，一方面帮助用户发现对自己有价值的信息，另一方面让信息能够展现在对它感兴趣的用户面前，从而实现信息消费者和信息生产者的双赢。

推荐系统的基本任务是联系用户和物品，解决信息过载的问题。

从物品的角度出发，推荐系统可以更好地发掘物品的长尾。

推荐算法的本质是通过一定的方式将用户和物品联系起来，而不同的推荐系统利用了不同的方式。如利用好友、用户的历史兴趣记录以及用户的注册信息等。

## 1.2 个性化推荐系统的应用

几乎所有的推荐系统应用都是由前台的展示页面、后台的日志系统以及推荐算法系统3部分构成的。

### 1.2.1 电子商务

亚马逊的个性化推荐列表：

*	**推荐结果的标题、缩略图以及其他内容属性**：告诉用户给它们推荐的是什么
*	**推荐结果的平均分**
*	**推荐理由**

亚马逊的两种推荐方式：

*	一种基于物品的推荐算法（item-based method）：给用户推荐那些和他们之前喜欢的物品相似的物品。
*	按照用户在Facebook的好友关系，给用户推荐他们的好友在亚马逊上喜欢的物品。

亚马逊相关推荐列表：

*	包含购买了这个商品的用户也经常购买的其他商品
*	包含浏览过这个商品的用户经常购买的其他商品

相关推荐列表最重要的应用就是打包销售

### 1.2.2 电影和视频网站

*	Netflix：基于物品的推荐算法，即给用户推荐和他们曾经喜欢的电影相似的电影
*	Youtube：基于物品的推荐算法。
*	Hulu：和Youtube类似

### 1.2.3 个性化音乐网络电台

个性化推荐的成功应用需要两个条件：

*	第一是存在信息过载因为如果用户可以很容易地从所有物品中找到喜欢的物品，就不需要个性化推荐了。
*	第二是用户大部分没有特别明确的需求，因为用户如果有明确的需求，可以直接通过搜索引擎找到感兴趣的物品。

思路：不允许用户点歌，而是给用户几种反馈方式——喜欢、不喜欢和跳过。经过用户一定时间的反馈，电台就可以从用户的历史行为中习得用户的兴趣模型，从而使用户的播放列表越来越符合用户对歌曲的兴趣。算法主要基于内容。

音乐推荐的特点：

*	**物品空间大**：物品数很多
*	**消费每首歌的代价很小**
*	**物品种类丰富**
*	**听一首歌耗时很少**
*	**物品重用率很高**
*	**用户充满激情**
*	**上下文相关**：包括用户当时的心情和所处情境
*	**次序很重要**
*	**很多播放列表资源**
*	**不需要用户全神贯注**
*	**高度社会化**：比如我们会和好友分享自己喜欢的音乐

### 1.2.4 社交网络

社交网络中的个性化推荐技术主要应用在3个方面：

*	利用用户的社交网络信息对用户进行个性化的物品推荐
*	信息流的会话推荐
*	给用户推荐好友

Facebook最宝贵的数组有两个，一个是用户之间的社交网络关系，另一个是用户的偏好信息。

### 1.2.5 个性化阅读

个性化阅读同样符合前面提出的需要个性化推荐的两个因素：

*	首先，互联网上的文章非常多，用户面临信息过载的问题；
*	其次，用户很多时候并没有必须看某篇具体文章的需求，他们只是想通过阅读特定领域的文章了解这些领域的动态。

个性化阅读工具：

*	Google Reader：允许用户关注自己感兴趣的人，然后看到所关注用户分享的文章
*	Zite：收集用户对文章的偏好信息
*	Digg：首先根据用户的Digg历史计算用户之间的兴趣相似度，然后给用户推荐和他兴趣相似的用户喜欢的文章。

### 1.2.6 基于位置的服务

基于位置的服务往往和社交网络结合在一起。

### 1.2.7 个性化邮件

Tapestry：通过分析用户阅读邮件的历史行为和习惯对新邮件进行重新排序，从而提高用户的工作效率。

### 1.2.8 个性化广告

个性化广告投放技术主要分为3种：

*	上下文广告：通过分析用户正在浏览的网页内容，投放和网页内容相关的广告。如：Adsense
*	搜索广告：通过分析用户在当前会话中的搜索记录，判断用户的搜索目的，投放和用户目的相关的广告。
*	个性化展示广告：根据用户的兴趣，对不同用户投放不同的展示广告。

## 1.3 推荐系统评测

一个好的推荐系统是能够令三方共赢的系统：用户、物品提供者和提供推荐系统的网站。

好的推荐系统不仅仅能够准确预测用户的行为，而且能够扩展用户的视野，帮助用户发现那些他们可能会感兴趣，但却不那么容易发现的东西。同时，推荐系统还要能够帮助商家将那些被埋没在长尾中的好商品介绍给可能会对它们感兴趣的用户。

指标：

*	精确度
*	覆盖度
*	新颖度
*	惊喜度
*	信任度
*	透明度

### 1.3.1 推荐系统实验方法

#### 1. 离线实验

几个步骤：

1.	通过日志系统获得用户行为数据，并按照一定格式生成一个标准的数据集；
2.	将数据集按照一定的规则分成训练集和测试集
3.	在训练集上训练用户兴趣模型，在测试集上进行预测
4.	通过事先定义的离线指标评测算法在测试集上的预测结果

优点：

*	不需要有对实际系统的控制权
*	不需要用户参与实验
*	速度快，可以测试大量算法

缺点：

*	无法计算商业上关心的指标
*	离线实验的指标和商业指标存在差距

#### 2. 用户调查

用户调查需要有一些真实用户，然他们在需要测试的推荐系统上完成一些任务。在他们完成任务时，我们需要观察和记录他们的行为，并让他们回答一些问题。最后，我们需要通过分析他们的行为和答案了解测试系统的性能。

优点：可以获得很多体现用户主观感受的指标，相对在线实验风险很低，出现错误后很容易弥补。

缺点：

*	招募测试用户代价较大，很难组织大规模的测试用户，因此会使测试结果的统计意义不足。
*	在很多时候设计双盲实验非常困难，而且用户在测试环境下的行为和真实环境下的行为可能有所不同，因而在测试环境下收集的测试指标可能在真实环境下无法重现。 

#### 3. 在线实验

在完成离线实验和必要的用户调查后，可以将推荐系统上线做AB测试，将它和旧的算法进行比较。

优点：可以公平获得不同算法实际在线时的性能指标，包括商业上关注的指标。

缺点：周期比较长，必须进行长期的实验才能得到可靠的结果。

一般来说，一个新的推荐算法最终上线，需要完成上面所说的3个实验：

*	首先，需要通过离线实验证明它在很多离线指标上优于现有的算法。
*	然后，需要通过用户调查确定它的用户满意度不低于现有的算法。
*	最后，通过在线的AB测试确定它在我们关心的指标上优于现有的算法。

### 1.3.2 评测指标

#### 1. 用户满意度

*	问卷调查
*	通过一些对用户行为的统计得到（点击率、用户停留时间、转化率等）

#### 2. 预测准确度

*	评分预测
*	TopN推荐：准确率(precision)/召回率(recall)
*	关于评分预测和TopN推荐的讨论：评分预测一直是推荐系统研究的热点，TopN推荐更符合实际的应用需求。

#### 3. 覆盖率

覆盖率(coverage)描述一个推荐系统对物品长尾的发掘能力。

覆盖率最简单的定义：为推荐系统能够推荐出来的物品占总物品集合的比例。

考虑到流行度分布：如果所有的物品都出现在推荐列表中，且出现的次数差不多，那么推荐系统发掘长尾的能力就很好。

*	信息熵
*	基尼系数（Gini Index）

社会学领域有一个著名的马太效应，即所谓强者更强，弱者更弱的效应。如果一个系统会增大热门物品和非热门物品的流行度差距，让热门的物品更加热门，不热门的物品更加不热门，那么这个系统就有马太效应。

推荐系统的初衷是希望消除马太效应，使得各种物品能被展示给它们感兴趣的某一类人群。很多研究表明现在主流的推荐算法（比如协同过滤算法）是具有马太效应的。评测推荐系统是否具有马太效应的简单办法就是使用基尼系数。如果G1是从初始用户行为中计算出的物品流行度的基尼系数，G2是从推荐列表中计算出的物品流行度的基尼系数，那么如果G2>G1，就说明推荐算法具有马太效应。

#### 4. 多样性

如果推荐列表比较多样，覆盖了用户绝大多数的兴趣点，那么就会增加用户找到感兴趣物品的概率。

多样性描述了推荐列表中物品两两之间的不相似性。

#### 5. 新颖性

新颖的推荐是指给用户推荐那些他们以前没有听说过的物品。在一个网站中实现新颖性的最简单办法是，把那些用户之前在网站中对其有过行为的物品从推荐列表中过滤掉。

#### 6. 惊喜度

令用户惊喜的推荐结果是和用户历史上喜欢的物品不相似，但用户却觉得满意的推荐。

提高推荐惊喜度需要提高推荐结果的用户满意度，同时降低推荐结果和用户历史兴趣的相似度。

#### 7. 信任度

度量推荐系统的信任度只能通过问卷调查的方式，询问用户是否信任推荐系统的推荐结果。

提高推荐系统的信任度主要有两种方法：

*	首先需要增加推荐系统的透明度(transparency)，而增加推荐系统透明度的主要办法是提供推荐解释。
*	其次是考虑用户的社交网络信息，利用用户的好友信息给用户做推荐，并且用好友进行推荐解释。

#### 8. 实时性

推荐系统的实时性包括两个方面：

*	首先，推荐系统需要实时地更新推荐列表来满足新的行为变化。
*	第二个方面是推荐系统需要能够将新加入系统的物品推荐给用户。者主要考验了推荐系统处理物品冷启动的能力。

##### 9. 健壮性

健壮性（即robust，鲁棒性）指标衡量了一个推荐系统抗击作弊的能力。

算法健壮性的评测主要利用模拟攻击：

*	首先，给定一个数据集和一个算法，可以用这个算法给这个数据集中的用户生成推荐列表。
*	然后，用常用的攻击方法向数据集中注入噪声数据，然后利用算法在植入噪声后的数据集上再次给用户生成推荐列表。
*	最后，通过比较攻击前后推荐列表的相似度评测算法的健壮性。

如果攻击后的推荐列表相对于攻击前没有发生大的变化，就说明算法比较健壮。

在实际系统中，提高系统的健壮性，除了选择健壮性高的算法，还有：

*	设计推荐系统时尽量使用代价比较高的用户行为。
*	在使用数据前，进行攻击检测，从而对数据进行清理。

#### 10. 商业目标

最本质的商业目标就是平均一个用户给公司带来的盈利，但计算一次需要比较大的代价。

#### 11. 总结

对于可以离线优化的指标，是应该在给定覆盖率、多样性、新颖性等限制条件下，尽量优化预测准确度。

### 1.3.3 评测维度

评测维度分为如下3种：

*	**用户维度**：主要包括用户的人口统计学信息、活跃度以及是不是新用户等
*	**物品维度**：包括物品的属性信息、流行度、平均分以及是不是新加入的物品等
*	**时间维度**：包括季节，是工作日还是周末，是白天还是晚上等

# 第2章 利用用户行为数据

基于用户行为分析的推荐算法是个性化推荐系统的重要算法，学术界一般将这种类型的算法称为协同过滤算法。顾名思义，协同过滤就是指用户可以齐心协力，通过不断地和网站互动，使自己的推荐列表能够不断过滤掉子集感兴趣的物品，从而越来越满足子集的需求。

## 2.1 用户行为数据简介

用户行为数据在网站上最简单的存在形式就是日志

用户行为在个性化推荐系统中一般分两种——*显性反馈行为*（explicit feedback）和*隐性反馈行为*（implicit feedback）。

显性反馈数据和隐性反馈数据的比较：

| | 显性反馈数据 | 隐性反馈数据 |
| --- | -------- | ------------ |
| 用户兴趣 | 明确 | 不明确 |
| 数量 | 较少 | 庞大 |
| 存储 | 数据库 | 分布式文件系统 |
| 实时读取 | 实时 | 有延迟 |
| 政府反馈 | 都有 | 只有正反馈 |

按照反馈的明确性分，用户行为数据可以分为显性反馈和隐性反馈，但按照反馈的方向分，又可以分为正反馈和负反馈。

各代表网站中显性反馈数据和隐性反馈数据的例子：

| | 显性反馈 | 隐性反馈 |
| --- | ---- | -------- |
| 视频网站 | 用户对视频的评分 | 用户观看视频的日志，浏览视频页面的日志 |
| 电子商务网站 | 用户对商品的评分 | 购买日志，浏览日志 |
| 门户网站 | 用户对新闻的评分 | 阅读新闻的日志 |
| 音乐网站 | 用户对音乐/歌手/专辑的评分 | 听歌的日志 |

用户行为的统一表示：

*	user id：产生行为的用户的唯一标识
*	item id：产生行为的对象的唯一标识
*	behavior type：行为的种类（比如使购买还是浏览）
*	context：产生行为的上下文，包括时间和地点等
*	behavior weight：行为的权重（如果使观看视频的行为，那么这个权重可以是观看时长；如果是打分行为，这个权重可以是分数）
*	behavior content：行为的内容（如果是评论行为，那么就是评论的文本；如果是打标签的行为，就是标签）

一般来说，不同的数据集包含不同的行为，目前比较有代表性的数据集有下面几个：

*	**无上下文信息的隐性反馈数据集**：每一条行为记录仅仅包含用户ID和物品ID。
*	**无上下文信息的显性反馈数据集**：每一条记录包含用户ID、物品ID和用户对物品的评分。
*	**有上下文信息的隐性反馈数据集**：每一条记录包含用户ID、物品ID和用户对物品产生行为的时间戳。
*	**有上下文信息的显性反馈数据集**：每一条记录包含用户ID、物品ID、用户对物品的评分和评分行为发生的时间戳。

## 2.2 用户行为分析

### 2.2.1 用户活跃度和物品流行度的分布

*长尾分布*。

### 2.2.2 用户活跃度和物品流行度的关系

协同过滤算法：

*	基于领域的方法（neighborhood-based）
*	隐语义模型（latent factor model）
*	基于图的随机游走算法（random walk on graph）

基于领域的方法主要包含下面两种算法：

*	**基于用户的协同过滤算法**：给用户推荐和他兴趣相似的其他用户喜欢的物品
*	**基于物品的协同过滤算法**：给用户推荐和他之前喜欢的物品相似的物品

## 2.3 实验设计和算法评测

评测推荐系统的3种方法：

*	离线实验
*	用户调查
*	在线实验

### 2.3.1 数据集

本章着重研究隐反馈数据集中的TopN推荐问题，因此忽略了数据集中的评分记录。

### 2.3.2 实验设计

协同过滤算法的离线实验一般如下设计。

*	首先，将用户行为数据集按照均匀分布随机分成M份（如M=8），挑选一份作为测试集，将剩下的M-1份作为训练集。
*	然后在训练集上建立用户兴趣模型，并在测试集上对用户行为进行预测，统计出相应的评测指标。
*	为了保证评测指标并不是过拟合的结果，需要进行M次实验，并且每次都使用不同的测试集。
*	然后将M次实验测出的评测指标的平均值作为最终的评测指标。

### 2.3.3 评测指标

*	准确率/召回率
*	覆盖率：发掘长尾的能力
*	新颖度：如果推荐出的物品都很热门，说明推荐的新颖度较低，否则说明推荐结果比较新颖

在计算平均流行度时对每个物品的流行度取对数，这是因为物品的流行度分布满足长尾分布，在取对数后，流行度的平均值更加稳定

## 2.4 基于邻域的算法

两大类：

*	一类是基于用户的协同过滤算法
*	另一类是基于物品的协同过滤算法

### 2.4.1 基于用户的协同过滤算法

#### 1. 基础算法

两个步骤：

1.	找到和目标用户兴趣相似的用户集合
2.	找到这个集合中的用户喜欢的，且目标用户没有听说过的物品推荐给目标用户

优化：

1.	物品-用户倒排表
2.	扫描倒排表中每个物品对应的用户列表

K的调整对推荐算法的各种指标产生的影响：

*	**准确率和召回率**：推荐系统的精度指标（准确率和召回率）并不和参数K成线性关系。一般选择K=80左右会获得比较高的准确率和召回率。推荐结果的精度对K也不是特别敏感，只要选在一定的区域内，就可以获得不错的精度。
*	**流行度**：K越大推荐结果就越热门
*	**覆盖率**：K越大则UserCF推荐结果的覆盖率越低

#### 2. 用户相似度计算的改进

惩罚了两用户共同兴趣列表种热门物品对他们相似度的影响

#### 3. 实际在线系统使用UserCF的例子

Digg中主要通过“顶”和“踩”两种行为表达自己对文章的看法。当用户顶了一篇文章，Digg就认为该用户对这篇文章有兴趣，而且愿意把这篇文章推荐给其他用户。

### 2.4.2 基于物品的协同过滤算法

基于物品的协同过滤算法是目前业界应用最多的算法。

#### 1. 基础算法

基于用户的协同过滤算法的缺点：

*	首先，随着网站的用户数目越来越大，计算用户兴趣相似度矩阵将越来越困难，其运算时间复杂度和空间复杂度的增长和用户数的增长近似于平方关系。
*	其次，基于用户的协同过滤很难对推荐结果作出解释。

基于物品的协同过滤算法（ItemCF）给用户推荐那些和他们之前喜欢的物品相似的物品。ItemCF算法并不利用物品的内容属性计算物品之间的相似度，它主要通过分析用户的行为记录计算物品之间的相似度。该算法认为，物品A和物品B具有很大的相似度是因为喜欢物品A的用户大都也喜欢物品B。

基于物品的协同过滤算法主要分为两步：

1.	计算物品之间的相似度
2.	根据物品的相似度和用户的历史行为给用户生成推荐列表

算法在不同K值下的性能：

*	**精度（准确率和召回率）**：ItemCF推荐结果的精度也是不和K成正相关或者负相关的，因此选择合适的K对获得最高精度是非常重要的。
*	**流行度**：和UserCF不同，参数K对ItemCF推荐结果流行度的影响也不是完全正相关的。随着K的增加，结果流行度会逐渐提高，但当K增加到一定程度，流行度就不会再有明显变化。
*	**覆盖率**：K增加会降低系统的覆盖率。

#### 2. 用户活跃度对用户相似度的影响

IUF（Inverse User Frequence），即用户活跃度对数的倒数的参数，即活跃用户对物品相似度的贡献应该小于不活跃的用户。

例如对于买了当当网80%图书的用户，为了避免相似度矩阵过于稠密，我们在实际计算中一般直接忽略他的兴趣列表，而不将其纳入到相似度计算的数据集中。

ItemCF-IUF在准确率和召回率两个指标上和ItemCF相似，但ItemCF-IUF明显提高了推荐结果的覆盖率，降低了推荐结果的流行度。从这个意义上说，ItemCF-IUF确实改进了ItemCF的综合性能。

#### 3. 物品相似度的归一化

研究中发现如果将ItemCF的相似度矩阵按最大值归一化，可以提高推荐的准确率。

归一化的好处不仅仅在于增加推荐的准确度，它还可以提高推荐的覆盖率和多样性。

### 2.4.3 UserCF和ItemCF的综合比较

UserCF给用户推荐那些和他有共同兴趣爱好的用户喜欢的物品，而ItemCF给用户推荐那些和他之前喜欢的物品类似的物品。

UserCF的推荐结果着重于反映和用户兴趣相似的小群体的热点，而ItemCF得推荐结果着重于维系用户的历史兴趣。

ItemCF的推荐更社会化，反映了用户所在的小型兴趣群体中物品的热门程度，而ItemCF得推荐更加个性化，反映了用户自己得兴趣传承。

优缺点对比：

| | UserCF | ItemCF |
| 性能 | 适用于用户较少得场合，如果用户很多，计算用户相似度矩阵得代价很大 | 适用于物品数明显小于用户数得场合，如果物品很多（网页），计算物品相似度矩阵代价很大 |
| 领域 | 时效性较强，用户个性化兴趣不太明显得领域 | 长尾物品丰富，用户个性化需求强烈得领域 |
| 实时性 | 用户有新行为，不一定造成推荐结果得立即变化 | 用户有新行为，一定会导致推荐结果得实时变化 | 
| 用户冷启动 | 在新用户对很少的物品产生行为后，不能立即对他进行个性化推荐，因为用户相似度表是每隔一段时间离线计算的 | 新用户只要对一个物品产生行为，就可以给他推荐和该物品相关的其他物品 | 
| 物品冷启动 | 新物品上线后一段时间，一旦有用户对物品产生行为，就可以将新物品推荐给和对它产生行为的用户兴趣相似的其他用户 | 没办法在不理线更新物品相似表的情况下将新物品推荐给用户 |
| 推荐理由 | 很难提供令用户信服的推荐解释 | 利用用户的历史行为给用户做推荐解释，可以令用户比较信服 |