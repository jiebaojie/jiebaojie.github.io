---
layout: post
notes: true
subtitle: "推荐系统实践"
comments: false
author: "项亮"
date: 2018-01-29 00:00:00

---

![](/img/notes/rs/recommenderSystemsPractice/recommender_systems_practice.jpg)

*   目录
{:toc }

# 第1章 好的推荐系统

## 1.1 什么是推荐系统

推荐系统的任务就是联系用户和信息，一方面帮助用户发现对自己有价值的信息，另一方面让信息能够展现在对它感兴趣的用户面前，从而实现信息消费者和信息生产者的双赢。

推荐系统的基本任务是联系用户和物品，解决信息过载的问题。

从物品的角度出发，推荐系统可以更好地发掘物品的长尾。

推荐算法的本质是通过一定的方式将用户和物品联系起来，而不同的推荐系统利用了不同的方式。如利用好友、用户的历史兴趣记录以及用户的注册信息等。

## 1.2 个性化推荐系统的应用

几乎所有的推荐系统应用都是由前台的展示页面、后台的日志系统以及推荐算法系统3部分构成的。

### 1.2.1 电子商务

亚马逊的个性化推荐列表：

*	**推荐结果的标题、缩略图以及其他内容属性**：告诉用户给它们推荐的是什么
*	**推荐结果的平均分**
*	**推荐理由**

亚马逊的两种推荐方式：

*	一种基于物品的推荐算法（item-based method）：给用户推荐那些和他们之前喜欢的物品相似的物品。
*	按照用户在Facebook的好友关系，给用户推荐他们的好友在亚马逊上喜欢的物品。

亚马逊相关推荐列表：

*	包含购买了这个商品的用户也经常购买的其他商品
*	包含浏览过这个商品的用户经常购买的其他商品

相关推荐列表最重要的应用就是打包销售

### 1.2.2 电影和视频网站

*	Netflix：基于物品的推荐算法，即给用户推荐和他们曾经喜欢的电影相似的电影
*	Youtube：基于物品的推荐算法。
*	Hulu：和Youtube类似

### 1.2.3 个性化音乐网络电台

个性化推荐的成功应用需要两个条件：

*	第一是存在信息过载因为如果用户可以很容易地从所有物品中找到喜欢的物品，就不需要个性化推荐了。
*	第二是用户大部分没有特别明确的需求，因为用户如果有明确的需求，可以直接通过搜索引擎找到感兴趣的物品。

思路：不允许用户点歌，而是给用户几种反馈方式——喜欢、不喜欢和跳过。经过用户一定时间的反馈，电台就可以从用户的历史行为中习得用户的兴趣模型，从而使用户的播放列表越来越符合用户对歌曲的兴趣。算法主要基于内容。

音乐推荐的特点：

*	**物品空间大**：物品数很多
*	**消费每首歌的代价很小**
*	**物品种类丰富**
*	**听一首歌耗时很少**
*	**物品重用率很高**
*	**用户充满激情**
*	**上下文相关**：包括用户当时的心情和所处情境
*	**次序很重要**
*	**很多播放列表资源**
*	**不需要用户全神贯注**
*	**高度社会化**：比如我们会和好友分享自己喜欢的音乐

### 1.2.4 社交网络

社交网络中的个性化推荐技术主要应用在3个方面：

*	利用用户的社交网络信息对用户进行个性化的物品推荐
*	信息流的会话推荐
*	给用户推荐好友

Facebook最宝贵的数组有两个，一个是用户之间的社交网络关系，另一个是用户的偏好信息。

### 1.2.5 个性化阅读

个性化阅读同样符合前面提出的需要个性化推荐的两个因素：

*	首先，互联网上的文章非常多，用户面临信息过载的问题；
*	其次，用户很多时候并没有必须看某篇具体文章的需求，他们只是想通过阅读特定领域的文章了解这些领域的动态。

个性化阅读工具：

*	Google Reader：允许用户关注自己感兴趣的人，然后看到所关注用户分享的文章
*	Zite：收集用户对文章的偏好信息
*	Digg：首先根据用户的Digg历史计算用户之间的兴趣相似度，然后给用户推荐和他兴趣相似的用户喜欢的文章。

### 1.2.6 基于位置的服务

基于位置的服务往往和社交网络结合在一起。

### 1.2.7 个性化邮件

Tapestry：通过分析用户阅读邮件的历史行为和习惯对新邮件进行重新排序，从而提高用户的工作效率。

### 1.2.8 个性化广告

个性化广告投放技术主要分为3种：

*	上下文广告：通过分析用户正在浏览的网页内容，投放和网页内容相关的广告。如：Adsense
*	搜索广告：通过分析用户在当前会话中的搜索记录，判断用户的搜索目的，投放和用户目的相关的广告。
*	个性化展示广告：根据用户的兴趣，对不同用户投放不同的展示广告。

## 1.3 推荐系统评测

一个好的推荐系统是能够令三方共赢的系统：用户、物品提供者和提供推荐系统的网站。

好的推荐系统不仅仅能够准确预测用户的行为，而且能够扩展用户的视野，帮助用户发现那些他们可能会感兴趣，但却不那么容易发现的东西。同时，推荐系统还要能够帮助商家将那些被埋没在长尾中的好商品介绍给可能会对它们感兴趣的用户。

指标：

*	精确度
*	覆盖度
*	新颖度
*	惊喜度
*	信任度
*	透明度

### 1.3.1 推荐系统实验方法

#### 1. 离线实验

几个步骤：

1.	通过日志系统获得用户行为数据，并按照一定格式生成一个标准的数据集；
2.	将数据集按照一定的规则分成训练集和测试集
3.	在训练集上训练用户兴趣模型，在测试集上进行预测
4.	通过事先定义的离线指标评测算法在测试集上的预测结果

优点：

*	不需要有对实际系统的控制权
*	不需要用户参与实验
*	速度快，可以测试大量算法

缺点：

*	无法计算商业上关心的指标
*	离线实验的指标和商业指标存在差距

#### 2. 用户调查

用户调查需要有一些真实用户，然他们在需要测试的推荐系统上完成一些任务。在他们完成任务时，我们需要观察和记录他们的行为，并让他们回答一些问题。最后，我们需要通过分析他们的行为和答案了解测试系统的性能。

优点：可以获得很多体现用户主观感受的指标，相对在线实验风险很低，出现错误后很容易弥补。

缺点：

*	招募测试用户代价较大，很难组织大规模的测试用户，因此会使测试结果的统计意义不足。
*	在很多时候设计双盲实验非常困难，而且用户在测试环境下的行为和真实环境下的行为可能有所不同，因而在测试环境下收集的测试指标可能在真实环境下无法重现。 

#### 3. 在线实验

在完成离线实验和必要的用户调查后，可以将推荐系统上线做AB测试，将它和旧的算法进行比较。

优点：可以公平获得不同算法实际在线时的性能指标，包括商业上关注的指标。

缺点：周期比较长，必须进行长期的实验才能得到可靠的结果。

一般来说，一个新的推荐算法最终上线，需要完成上面所说的3个实验：

*	首先，需要通过离线实验证明它在很多离线指标上优于现有的算法。
*	然后，需要通过用户调查确定它的用户满意度不低于现有的算法。
*	最后，通过在线的AB测试确定它在我们关心的指标上优于现有的算法。

### 1.3.2 评测指标

#### 1. 用户满意度

*	问卷调查
*	通过一些对用户行为的统计得到（点击率、用户停留时间、转化率等）

#### 2. 预测准确度

*	评分预测
*	TopN推荐：准确率(precision)/召回率(recall)
*	关于评分预测和TopN推荐的讨论：评分预测一直是推荐系统研究的热点，TopN推荐更符合实际的应用需求。

#### 3. 覆盖率

覆盖率(coverage)描述一个推荐系统对物品长尾的发掘能力。

覆盖率最简单的定义：为推荐系统能够推荐出来的物品占总物品集合的比例。

考虑到流行度分布：如果所有的物品都出现在推荐列表中，且出现的次数差不多，那么推荐系统发掘长尾的能力就很好。

*	信息熵
*	基尼系数（Gini Index）

社会学领域有一个著名的马太效应，即所谓强者更强，弱者更弱的效应。如果一个系统会增大热门物品和非热门物品的流行度差距，让热门的物品更加热门，不热门的物品更加不热门，那么这个系统就有马太效应。

推荐系统的初衷是希望消除马太效应，使得各种物品能被展示给它们感兴趣的某一类人群。很多研究表明现在主流的推荐算法（比如协同过滤算法）是具有马太效应的。评测推荐系统是否具有马太效应的简单办法就是使用基尼系数。如果G1是从初始用户行为中计算出的物品流行度的基尼系数，G2是从推荐列表中计算出的物品流行度的基尼系数，那么如果G2>G1，就说明推荐算法具有马太效应。

#### 4. 多样性

如果推荐列表比较多样，覆盖了用户绝大多数的兴趣点，那么就会增加用户找到感兴趣物品的概率。

多样性描述了推荐列表中物品两两之间的不相似性。

#### 5. 新颖性

新颖的推荐是指给用户推荐那些他们以前没有听说过的物品。在一个网站中实现新颖性的最简单办法是，把那些用户之前在网站中对其有过行为的物品从推荐列表中过滤掉。

#### 6. 惊喜度

令用户惊喜的推荐结果是和用户历史上喜欢的物品不相似，但用户却觉得满意的推荐。

提高推荐惊喜度需要提高推荐结果的用户满意度，同时降低推荐结果和用户历史兴趣的相似度。

#### 7. 信任度

度量推荐系统的信任度只能通过问卷调查的方式，询问用户是否信任推荐系统的推荐结果。

提高推荐系统的信任度主要有两种方法：

*	首先需要增加推荐系统的透明度(transparency)，而增加推荐系统透明度的主要办法是提供推荐解释。
*	其次是考虑用户的社交网络信息，利用用户的好友信息给用户做推荐，并且用好友进行推荐解释。

#### 8. 实时性

推荐系统的实时性包括两个方面：

*	首先，推荐系统需要实时地更新推荐列表来满足新的行为变化。
*	第二个方面是推荐系统需要能够将新加入系统的物品推荐给用户。者主要考验了推荐系统处理物品冷启动的能力。

##### 9. 健壮性

健壮性（即robust，鲁棒性）指标衡量了一个推荐系统抗击作弊的能力。

算法健壮性的评测主要利用模拟攻击：

*	首先，给定一个数据集和一个算法，可以用这个算法给这个数据集中的用户生成推荐列表。
*	然后，用常用的攻击方法向数据集中注入噪声数据，然后利用算法在植入噪声后的数据集上再次给用户生成推荐列表。
*	最后，通过比较攻击前后推荐列表的相似度评测算法的健壮性。

如果攻击后的推荐列表相对于攻击前没有发生大的变化，就说明算法比较健壮。

在实际系统中，提高系统的健壮性，除了选择健壮性高的算法，还有：

*	设计推荐系统时尽量使用代价比较高的用户行为。
*	在使用数据前，进行攻击检测，从而对数据进行清理。

#### 10. 商业目标

最本质的商业目标就是平均一个用户给公司带来的盈利，但计算一次需要比较大的代价。

#### 11. 总结

对于可以离线优化的指标，是应该在给定覆盖率、多样性、新颖性等限制条件下，尽量优化预测准确度。

### 1.3.3 评测维度

评测维度分为如下3种：

*	**用户维度**：主要包括用户的人口统计学信息、活跃度以及是不是新用户等
*	**物品维度**：包括物品的属性信息、流行度、平均分以及是不是新加入的物品等
*	**时间维度**：包括季节，是工作日还是周末，是白天还是晚上等

# 第2章 利用用户行为数据

基于用户行为分析的推荐算法是个性化推荐系统的重要算法，学术界一般将这种类型的算法称为协同过滤算法。顾名思义，协同过滤就是指用户可以齐心协力，通过不断地和网站互动，使自己的推荐列表能够不断过滤掉子集感兴趣的物品，从而越来越满足子集的需求。

## 2.1 用户行为数据简介

用户行为数据在网站上最简单的存在形式就是日志

用户行为在个性化推荐系统中一般分两种——*显性反馈行为*（explicit feedback）和*隐性反馈行为*（implicit feedback）。

显性反馈数据和隐性反馈数据的比较：

| | 显性反馈数据 | 隐性反馈数据 |
| --- | -------- | ------------ |
| 用户兴趣 | 明确 | 不明确 |
| 数量 | 较少 | 庞大 |
| 存储 | 数据库 | 分布式文件系统 |
| 实时读取 | 实时 | 有延迟 |
| 政府反馈 | 都有 | 只有正反馈 |

按照反馈的明确性分，用户行为数据可以分为显性反馈和隐性反馈，但按照反馈的方向分，又可以分为正反馈和负反馈。

各代表网站中显性反馈数据和隐性反馈数据的例子：

| | 显性反馈 | 隐性反馈 |
| --- | ---- | -------- |
| 视频网站 | 用户对视频的评分 | 用户观看视频的日志，浏览视频页面的日志 |
| 电子商务网站 | 用户对商品的评分 | 购买日志，浏览日志 |
| 门户网站 | 用户对新闻的评分 | 阅读新闻的日志 |
| 音乐网站 | 用户对音乐/歌手/专辑的评分 | 听歌的日志 |

用户行为的统一表示：

*	user id：产生行为的用户的唯一标识
*	item id：产生行为的对象的唯一标识
*	behavior type：行为的种类（比如使购买还是浏览）
*	context：产生行为的上下文，包括时间和地点等
*	behavior weight：行为的权重（如果使观看视频的行为，那么这个权重可以是观看时长；如果是打分行为，这个权重可以是分数）
*	behavior content：行为的内容（如果是评论行为，那么就是评论的文本；如果是打标签的行为，就是标签）

一般来说，不同的数据集包含不同的行为，目前比较有代表性的数据集有下面几个：

*	**无上下文信息的隐性反馈数据集**：每一条行为记录仅仅包含用户ID和物品ID。
*	**无上下文信息的显性反馈数据集**：每一条记录包含用户ID、物品ID和用户对物品的评分。
*	**有上下文信息的隐性反馈数据集**：每一条记录包含用户ID、物品ID和用户对物品产生行为的时间戳。
*	**有上下文信息的显性反馈数据集**：每一条记录包含用户ID、物品ID、用户对物品的评分和评分行为发生的时间戳。

## 2.2 用户行为分析

### 2.2.1 用户活跃度和物品流行度的分布

*长尾分布*。

### 2.2.2 用户活跃度和物品流行度的关系

协同过滤算法：

*	基于领域的方法（neighborhood-based）
*	隐语义模型（latent factor model）
*	基于图的随机游走算法（random walk on graph）

基于领域的方法主要包含下面两种算法：

*	**基于用户的协同过滤算法**：给用户推荐和他兴趣相似的其他用户喜欢的物品
*	**基于物品的协同过滤算法**：给用户推荐和他之前喜欢的物品相似的物品

## 2.3 实验设计和算法评测

评测推荐系统的3种方法：

*	离线实验
*	用户调查
*	在线实验

### 2.3.1 数据集

本章着重研究隐反馈数据集中的TopN推荐问题，因此忽略了数据集中的评分记录。

### 2.3.2 实验设计

协同过滤算法的离线实验一般如下设计。

*	首先，将用户行为数据集按照均匀分布随机分成M份（如M=8），挑选一份作为测试集，将剩下的M-1份作为训练集。
*	然后在训练集上建立用户兴趣模型，并在测试集上对用户行为进行预测，统计出相应的评测指标。
*	为了保证评测指标并不是过拟合的结果，需要进行M次实验，并且每次都使用不同的测试集。
*	然后将M次实验测出的评测指标的平均值作为最终的评测指标。

### 2.3.3 评测指标

*	准确率/召回率
*	覆盖率：发掘长尾的能力
*	新颖度：如果推荐出的物品都很热门，说明推荐的新颖度较低，否则说明推荐结果比较新颖

在计算平均流行度时对每个物品的流行度取对数，这是因为物品的流行度分布满足长尾分布，在取对数后，流行度的平均值更加稳定

## 2.4 基于邻域的算法

两大类：

*	一类是基于用户的协同过滤算法
*	另一类是基于物品的协同过滤算法

### 2.4.1 基于用户的协同过滤算法

#### 1. 基础算法

两个步骤：

1.	找到和目标用户兴趣相似的用户集合
2.	找到这个集合中的用户喜欢的，且目标用户没有听说过的物品推荐给目标用户

优化：

1.	物品-用户倒排表
2.	扫描倒排表中每个物品对应的用户列表

K的调整对推荐算法的各种指标产生的影响：

*	**准确率和召回率**：推荐系统的精度指标（准确率和召回率）并不和参数K成线性关系。一般选择K=80左右会获得比较高的准确率和召回率。推荐结果的精度对K也不是特别敏感，只要选在一定的区域内，就可以获得不错的精度。
*	**流行度**：K越大推荐结果就越热门
*	**覆盖率**：K越大则UserCF推荐结果的覆盖率越低

#### 2. 用户相似度计算的改进

惩罚了两用户共同兴趣列表种热门物品对他们相似度的影响

#### 3. 实际在线系统使用UserCF的例子

Digg中主要通过“顶”和“踩”两种行为表达自己对文章的看法。当用户顶了一篇文章，Digg就认为该用户对这篇文章有兴趣，而且愿意把这篇文章推荐给其他用户。

### 2.4.2 基于物品的协同过滤算法

基于物品的协同过滤算法是目前业界应用最多的算法。

#### 1. 基础算法

基于用户的协同过滤算法的缺点：

*	首先，随着网站的用户数目越来越大，计算用户兴趣相似度矩阵将越来越困难，其运算时间复杂度和空间复杂度的增长和用户数的增长近似于平方关系。
*	其次，基于用户的协同过滤很难对推荐结果作出解释。

基于物品的协同过滤算法（ItemCF）给用户推荐那些和他们之前喜欢的物品相似的物品。ItemCF算法并不利用物品的内容属性计算物品之间的相似度，它主要通过分析用户的行为记录计算物品之间的相似度。该算法认为，物品A和物品B具有很大的相似度是因为喜欢物品A的用户大都也喜欢物品B。

基于物品的协同过滤算法主要分为两步：

1.	计算物品之间的相似度
2.	根据物品的相似度和用户的历史行为给用户生成推荐列表

算法在不同K值下的性能：

*	**精度（准确率和召回率）**：ItemCF推荐结果的精度也是不和K成正相关或者负相关的，因此选择合适的K对获得最高精度是非常重要的。
*	**流行度**：和UserCF不同，参数K对ItemCF推荐结果流行度的影响也不是完全正相关的。随着K的增加，结果流行度会逐渐提高，但当K增加到一定程度，流行度就不会再有明显变化。
*	**覆盖率**：K增加会降低系统的覆盖率。

#### 2. 用户活跃度对用户相似度的影响

IUF（Inverse User Frequence），即用户活跃度对数的倒数的参数，即活跃用户对物品相似度的贡献应该小于不活跃的用户。

例如对于买了当当网80%图书的用户，为了避免相似度矩阵过于稠密，我们在实际计算中一般直接忽略他的兴趣列表，而不将其纳入到相似度计算的数据集中。

ItemCF-IUF在准确率和召回率两个指标上和ItemCF相似，但ItemCF-IUF明显提高了推荐结果的覆盖率，降低了推荐结果的流行度。从这个意义上说，ItemCF-IUF确实改进了ItemCF的综合性能。

#### 3. 物品相似度的归一化

研究中发现如果将ItemCF的相似度矩阵按最大值归一化，可以提高推荐的准确率。

归一化的好处不仅仅在于增加推荐的准确度，它还可以提高推荐的覆盖率和多样性。

### 2.4.3 UserCF和ItemCF的综合比较

UserCF给用户推荐那些和他有共同兴趣爱好的用户喜欢的物品，而ItemCF给用户推荐那些和他之前喜欢的物品类似的物品。

UserCF的推荐结果着重于反映和用户兴趣相似的小群体的热点，而ItemCF得推荐结果着重于维系用户的历史兴趣。

ItemCF的推荐更社会化，反映了用户所在的小型兴趣群体中物品的热门程度，而ItemCF得推荐更加个性化，反映了用户自己得兴趣传承。

优缺点对比：

| | UserCF | ItemCF |
| 性能 | 适用于用户较少得场合，如果用户很多，计算用户相似度矩阵得代价很大 | 适用于物品数明显小于用户数得场合，如果物品很多（网页），计算物品相似度矩阵代价很大 |
| 领域 | 时效性较强，用户个性化兴趣不太明显得领域 | 长尾物品丰富，用户个性化需求强烈得领域 |
| 实时性 | 用户有新行为，不一定造成推荐结果得立即变化 | 用户有新行为，一定会导致推荐结果得实时变化 | 
| 用户冷启动 | 在新用户对很少的物品产生行为后，不能立即对他进行个性化推荐，因为用户相似度表是每隔一段时间离线计算的 | 新用户只要对一个物品产生行为，就可以给他推荐和该物品相关的其他物品 | 
| 物品冷启动 | 新物品上线后一段时间，一旦有用户对物品产生行为，就可以将新物品推荐给和对它产生行为的用户兴趣相似的其他用户 | 没办法在不理线更新物品相似表的情况下将新物品推荐给用户 |
| 推荐理由 | 很难提供令用户信服的推荐解释 | 利用用户的历史行为给用户做推荐解释，可以令用户比较信服 |

离线实验的性能在推荐算法时并不起决定作用：

*	首先应该满足产品的需求
*	其次需要看实现代价
*	最后，离线指标和点击率等在线指标不一定成正比。

一般来说，这两种算法经过优化后，最终得到的离线性能是近似的。

#### 哈利波特问题

《哈利波特》太热门了，购买任何一本书的人几乎都会购买它。实际应用中，热门的商品仍然会获得比较大的相似度。

解决方案：加大对热门物品的惩罚

第二个问题：两个不同领域的最热门物品之间往往具有比较高的相似度。

解决方案：引入物品的内容数据，比如对不同领域的物品降低权重等。

## 2.5 隐语义模型

### 2.5.1 基础算法

核心思想：通过隐含特征（latent factor）联系用户兴趣和物品。

### 2.5.2 基于LFM的实际系统的例子

雅虎首页个性化设计

### 2.5.3 LFM和基于领域的方法的比较

*	**理论基础**：LFM具有比较好的理论基础，它是一种学习方法，通过优化一个设定的指标建立最优的模型。基于领域的方法更多的是一种基于统计的方法，并没有学习过程。
*	**离线计算的空间复杂度**：LFM大量节省了训练过程中的内存
*	**离线计算的时间复杂度**：LFM的时间复杂度要稍高于UserCF和ItemCF，这主要是因为该算法需要多次迭代。但总体上，这两种算法在时间复杂度上没有质的差别。
*	**在线实时推荐**：LFM不太适合用于物品数非常庞大的系统；LFM不能进行在线实时推荐，也就是说，当用户有了新的行为后，他的推荐列表不会发生变化。
*	**推荐解释**：ItemCF算法支持很好的推荐解释，它可以利用用户的历史行为解释推荐结果。但LFM无法提供这样的解释。

## 2.6 基于图的模型

### 2.6.1 用户行为数据的二分图表示

用户物品二分图

### 2.6.2 基于图的推荐算法

PersonalRank算法：假设要给用户u进行个性化推荐，可以从用户u对应的节点开始在用户物品二分图上进行随机游走。游走到任何一个节点时，首先按照一定的概率决定是继续游走，还是停止这次游走并从该节点开始重新游走。如果决定继续游走，那么就从当前节点指向的节点中按照均匀分布随机选择一个节点作为游走下次经过的节点。这样，经过很多次随机游走后，每个物品节点被访问到的概率会收敛到一个数。最终的推荐列表中物品的权重就是物品节点的访问概率。

缺点：时间复杂度非常高。

解决方案：

*	减少迭代次数，在收敛之前就停止。这样会影响最终的精度，但一般来说影响不会特别大。
*	另一种方法就是从矩阵论触发，重新设计算法。

# 第3章 推荐系统冷启动问题

## 3.1 冷启动问题简介

冷启动问题（cold start）主要分3类：

*	**用户冷启动**：用户冷启动主要解决如何给新用户做个性化推荐的问题
*	**物品冷启动**：物品冷启动主要解决如何将新的物品推荐给可能对它感兴趣的用户这一问题
*	**系统冷启动**：系统冷启动主要解决如何在一个新开发的网站上（还没有用户，也没有用户行为，只有一些物品的信息）设计个性化推荐系统，从而在网站刚发布时就让用户体验到个性化推荐服务这一问题

解决方案：

*	**提供非个性化的推荐**：热门排行榜
*	利用用户注册时提供的年龄、性别等数据做粗粒度的个性化
*	利用用户的社交网络账号登录（需要用户授权），导入用户在社交网站上的好友信息，然后给用户推荐其好友喜欢的物品
*	要求用户在登录时对一些物品进行反馈，收集用户对这些物品的兴趣信息，然后给用户推荐那些和这些物品相似的物品
*	对于新加入的物品，可以利用内容信息，将它们推荐给喜欢过和它们相似的物品的用户
*	在系统冷启动时，可以引入专家的知识，通过一定的高效方式迅速建立起物品的相关度表

## 3.2 利用用户注册信息

3种用户注册信息：

*	**人口统计学信息**：包括用户的年龄、性别、职业、民族、学历和居住地
*	**用户兴趣的描述**：有一些网站会让用户用文字描述他们的兴趣
*	**从其他网站导入的用户站外行为数据**

基于注册信息的个性化推荐流程基本如下：

1.	获取用户的注册信息；
2.	根据用户的注册信息对用户分类；
3.	给用户推荐他所属分类中用户喜欢的物品

5种不同算法：

*	MostPopular：给用户推荐最热门
*	GenderMostPopular：给用户推荐对于和他同性别的用户最热门
*	AgeMostPopular：给用户推荐对于和他同一个年龄段的用户最热门
*	CountryMostPopular：给用户推荐对于和他同一个国家的用户最热门
*	DemographicMostPopular：给用户推荐对于和他同性别、年龄段、国家的用户最热门

利用的用户人口统计学特征越多，越能准确地预测用户兴趣。

## 3.3 选择合适的物品启动用户的兴趣68

解决用户冷启动问题的另一个方法是在新用户第一次访问推荐系统时，不立即给用户展示推荐结果，而是给用户提供一些物品，让用户反馈他们对这些物品的兴趣，然后根据用户反馈给提供个性化推荐。

一般来说，能够用来启动用户兴趣的物品需要具有以下特点：

*	**比较热门**
*	**具有代表性和区分性**
*	**启动物品集合需要有多样性**

Nadav Golbandi的算法首先会从所有用户中找到具有最高区分度的物品，然后将用户分成3类（喜欢、不喜欢、不知道）。然后在每类用户中再找到最具区分度的物品，然后将每一类用户又各自分为3类，也就是将总用户分成9类，然后这样继续下去，最终可以通过对一系列物品的看法将用户进行分类。而在冷启动时，我们从根节点开始询问用户对该节点物品的看法，然后根据用户的选择将用户放到不同的分支，直到进入最后的叶子节点，此时我们就已经对用户的兴趣有了比较清楚的了解，从而可以开始对用户进行比较准确地个性化推荐。

## 3.4 利用物品的内容信息

物品冷启动需要解决的问题是如何将新加入的物品推荐给对它感兴趣的用户。

方案：利用物品的内容信息计算物品相关表，并且频繁地更新相关表。

一般来说，物品的内容可以通过向量空间模型表示，该模型会将物品表示成一个关键词向量。

内容过滤算法忽视了用户行为，从而也忽视了物品的流行度以及用户行为中包含的规律，所以它的精度比较低，但结果的新颖度却比较高。

向量空间模型在内容数据丰富时可以获得比较好的效果。

## 3.5 发挥专家的作用

很多推荐系统在建立时，既没有用户的行为数据，也没有充足的物品内容信息来计算准确的物品相似度。那么，为了在推荐系统建立时就让用户得到比较好的体验，很多系统都利用专家进行标注。

通过专家和机器学习相结合的方法解决了系统冷启动问题：在专家标记一定的样本后，可以使用自然语言理解和机器学习技术，通过分析用户对电影的评论和电影的一些内容属性对电影（特别是新电影）进行自己的标记。同时也可以设计让用户对基因进行反馈的界面，希望通过用户反馈不断改进基因系统。

# 第4章 利用用户标签数据

推荐系统的目的是联系用户的兴趣和物品，这种联系需要依赖不同的媒介。

联系用户兴趣和物品的3种方式：

*	利用用户喜欢过的物品，给用户推荐与他喜欢过的物品相似的物品（基于物品的算法）
*	利用和用户兴趣相似的其他用户，给用户推荐那些和他们兴趣爱好相似的其他用户喜欢的物品（基于用户的算法）
*	通过一些特征（feature）联系用户和物品，给用户推荐那些具有用户喜欢的特征的物品。

标签是一种无层次化结构的、用来描述信息的关键词，它可以用来描述物品的语义。

标签应用一般分为两种：

*	一种是让作者或者专家给物品打标签
*	另一种是让普通用户给物品打标签，也就四UGC（User Generated Content，用户生成的内容）的标签应用。

当一个用户对一个物品打上一个标签，这个标签一方面描述了用户的兴趣，另一方面则表示了物品的语义，从而将用户和物品联系了起来。

## 4.1 UGC标签系统的代表应用

### 4.1.1 Delicious

Delicious可算是标签系统里的开山鼻祖，它允许用户给互联网上的每个网页打标签，从而通过标签重新组织整个互联网。

### 4.1.2 CiteULike

CiteULike是一个著名的论文书签网站，它允许研究人员提交或者收藏自己感兴趣的论文并且给论文打标签，从而帮助用户更好地发现和自己研究领域相关的优秀论文。

### 4.1.3 Last.fm

Last.fm是一家著名的音乐网站，它通过分析用户的听歌行为预测用户对音乐的兴趣，从而给用户推荐个性化的音乐。为了在不进行复杂音频分析的情况下获得音乐的内容信息，Last.fm引入了UGC标签系统，让用户用标签标记音乐和歌手。

### 4.1.4 豆瓣

豆瓣是中国著名的评论和社交网络，同时也是中国个性化推荐领域的领军企业之一。它允许用户对图书和电影打标签，借此获得图书和电影的内容信息和语义，并用这种信息改善推荐效果。

### 4.1.5 Hulu

Hulu是美国著名的视频网站。视频作为一种最为复杂的多媒体，获取它的内容信息是最困难的，因此Hulu也引入了用户标签系统来让用户对电视剧和电影进行标记。

标签系统的最大优势：发挥群体的只能，获得对物品内容信息比较准确的关键词描述，而准确的内容信息是提升个性化推荐系统性能的重要资源。

## 4.2 标签系统中的推荐问题

两个主要问题：

*	如何利用用户打标签的行为为其推荐物品（基于标签的推荐）？
*	如何在用户给物品打标签时为其推荐适合该物品的标签（标签推荐）？

需要解答的3个问题：

*	用户为什么要打标签？
*	用户怎么打标签？
*	用户打什么样的标签？

### 4.2.1 用户为什么进行标注

社会维度：

*	有些用户标注是给内容上传者使用的（便于上传者组织自己的信息）
*	有些用户标注是给广告用户使用的（便于帮助其他用户找到信息）

功能维度：

*	有些标注用于更好地组织内容，方便用户将来的查找
*	另一些标注用于传达某种信息，比如照片的拍摄时间和地点等

### 4.2.2 用户如何打标签

标签的流行度分布也呈现非常典型的长尾分布。

### 4.2.3 用户打什么样的标签

如下几类：

*	**表明物品是什么**
*	**表明物品的种类**
*	**表明谁拥有物品**
*	**表达用户的观点**
*	**用户相关的标签**
*	**用户的任务**

Hulu的电视剧标签类型：

*	**类型（Genre）**
*	**时间（Time）**
*	**人物（People）**
*	**地点（Place）**
*	**语言（Language）**
*	**奖项（Awards）**
*	**其他（Details）**

## 4.3 基于标签的推荐系统

三元组（用户、物品、标签）

### 4.3.1 实验设置

本节将数据集随机分成10份。这里分割的键值撕用户和物品，不包括标签。也就是说，用户对物品的多个标签记录要么都被分进训练集，要么都被分进测试集，不会一部分分在训练集，另一部分在测试集中。

为了全面评测个性化推荐的性能，我们同时评测了推荐结果的覆盖率（coverage）、多样性（diversity）和新颖度。

### 4.3.2 一个简单的算法

*	统计每个用户最常用的标签
*	对于每个标签，统计被打过这个标签次数最多的物品
*	对于一个用户，首先找到他常用的标签，然后找到具有这些标签的最热门物品推荐给这个用户

### 4.3.3 算法的改进

#### 1. TF-IDF

前面这个算法倾向于给热门标签对应的热门物品很大的权重，因此会造成推荐热门的物品给用户，从而降低推荐结果的新颖性。另外，这个算法利用用户的标签向量对用户兴趣建模，其中每个标签都是用户使用过的标签，而标签的权重是用户使用该标签的次数。这种建模方法的缺点是给热门标签过大的权重，从而不能反应用户个性化的兴趣。

方案：

*	借鉴TF-IDF的思想对热门标签进行惩罚
*	借鉴TF-IDF的思想对热门物品进行惩罚

#### 2. 数据稀疏性

对于新用户或者新物品，交集的标签数量会很少

标签扩展：标签扩展的本质是对每个标签找到和它相似的标签，也就是计算标签之间的相似度。

相似度方案：

*	同义词
*	认为同一个物品上的不通标签具有某种相似度，那么当两个标签同时出现在很多物品的标签集合中时，我们就可以认为这两个标签具有较大的相似度。

#### 3. 标签清理

标签清理的意义：

*	标签系统里经常出现词形不同、语义相同的标签
*	标签清理的另一个重要意义在于讲标签作为推荐解释

标签清理方法：

*	去除词频很高的停止词
*	去除因词根不通造成的同义词，比如recommender system和recommendation system
*	去除因分隔符造成的同义词，比如collaborative_filtering和collaborative-filtering

为了控制标签的质量，很多网站也采用了让用户进行反馈的思想，即让用户告诉系统某个标签是否合适。


### 4.3.4 基于图的推荐算法

3种不同的顶点：

*	用户顶点
*	物品顶点
*	标签顶点

用户给物品打了标签，那么就是在途中增加3条边（用户节点和物品节点之间的边可略去，SimpleTagGraph）

用PersonalRank算法

### 4.3.5 基于标签的推荐解释

基于标签的推荐其最大好处是可以利用标签做推荐的解释。

豆瓣将推荐结果的可解释性拆分成了两部分：

*	首先让用户觉得标签云是有道理的
*	然后让用户觉得从某个标签推荐出某本书也是有道理的

## 4.4 给用户推荐标签

### 4.4.1 为什么要给用户推荐标签

*	方便用户输入标签
*	提高标签质量

### 4.4.2 如何给用户推荐标签

4种方法：

*	给用户u推荐整个系统里最热门的标签（PopularTags）
*	给用户u推荐物品i上最热门的标签（ItemPopularTags）
*	给用户u推荐自己经常使用的标签（UserPopularTags）
*	将前两种算法推荐结果线性加权，然后生成最终的推荐结果（HybridPopularTags）。在将两个列表线性相加时都将两个列表按最大值做了归一化。

### 4.4.3 实验设置

前面提到的基于统计用户和物品常用标签的算法有一个缺点，就是对新用户或者不热门额物品很难有推荐结果。

解决思路：

*	从物品的内容数据中抽取关键词作为标签。
*	针对有结果，但结果不太多的情况，实现标签扩展，关键就是计算标签之间的相似度。

### 4.4.4 基于图的标签推荐算法

## 4.5 扩展阅读

# 第5章 利用上下文信息

## 5.1 时间上下文信息

### 5.1.1 时间效应简介

时间信息对用户兴趣的影响表现在以下几个方面：

*	**用户兴趣是变化的**
*	**物品也是有生命周期的**
*	**季节效应**

### 5.1.2 时间效应举例

### 5.1.3 系统时间特性的分析

通过统计如下信息研究系统的时间特性：

*	**数据集每天独立用户数的增长情况**
*	**系统的物品变化情况**
*	**用户访问情况**

#### 1. 数据集的选择

#### 2. 物品的生存周期和系统的时效性

我们可以用如下指标度量网站中物品的生命周期

*	**物品平均在线天数**
*	**相隔T天系统物品流行度向量的平均相似度**

### 5.1.4 推荐系统的实时性

用户兴趣是不断变化的，其变化体现在用户不断增加的新行为中。一个实时的推荐系统需要能够实时响应用户新的行为，让推荐列表不断变化，从而满足用户不断变化的兴趣。

实现推荐系统的实时性除了对用户行为的存取有实时性要求，还要求推荐算法本身具有实时性，而推荐算法本身的实时性意味着：

*	实时推荐系统不能每天都给所有用户离线计算推荐结果，然后在线展示昨天计算出来的结果。所以，要求在每个用户访问推荐系统时，都根据用户这个时间点前的行为实时计算推荐列表。
*	推荐算法需要平衡考虑用户的近期行为和长期行为，既要让推荐列表反应出用户近期行为所体现的兴趣变化，又不能让推荐列表完全受用户近期行为的影响，要保证推荐列表对用户兴趣预测的延续性。

### 5.1.5 推荐算法的时间多样性

推荐系统每天推荐结果的变化程度被定义为推荐系统的时间多样性。时间多样性高的推荐系统中用户会经常看到不同的推荐结果。

提高推荐结果的时间多样性需要分两步解决：

*	首先，需要保证推荐系统能够在用户有了新的行为后及时调整推荐结果，使推荐结果满足用户最近的兴趣
*	其次，需要保证推荐系统在用户没有新的行为时也能够经常变化一下结果，具有一定的时间多样性

如果用户没有行为，如何保证给用户的推荐结果具有一定的时间多样性？

*	在生成推荐结果时加入一定的随机性
*	记录用户每天看到的推荐结果，然后在每天给用户进行推荐时，对他前几天看到过很多次的推荐结果进行适当地降权
*	每天给用户使用不同的推荐算法

推荐系统需要首先保证推荐的精度，在此基础上适当地考虑时间多样性。

### 5.1.6 时间上下文推荐算法

#### 1. 最近最热门

#### 2. 时间上下文相关的ItemCF算法

两种时间效应：

*	**物品相似度**：用户在相隔很短的时间内喜欢的物品具有更高相似度。
*	**在线推荐**：用户近期行为相比用户很久之前的行为，更能体现用户现在的兴趣。

#### 3. 时间上下文相关的UserCF算法

两个方面利用时间信息：

*	**用户兴趣相似度**：如果两个用户同时喜欢相同的物品，那么这两个用户应该有更大的兴趣相似度
*	**相似兴趣用户的最近行为**：我们应该给用户推荐和他兴趣相似的用户最近喜欢的物品

### 5.1.7 时间段图模型

### 5.1.8 离线实验

#### 1. 实验设置

对每一个用户，将物品按照该用户对物品的行为时间从早到晚排序，然后将用户最后一个产生行为的物品作为测试集，并将这之前的用户对物品的行为记录作为训练集。

## 5.2 地点上下文信息

除了时间，地点作为一种重要的空间特征，也是一种重要的上下文信息。不同地区的用户兴趣有所不同，用户到了不同的地方，兴趣也会有所不同。

### 基于位置的推荐算法

LARS（Location Aware Recommender System，位置感知推荐系统）：该系统首先将物品分为两类，一类是有空间属性的，比如餐馆、商店、旅游景点等；另一类是无空间属性的物品，比如图书和电影等。同时，它将用户也分为两类，一类是有空间属性的，比如给出了用户现在的地址（国家、城市、邮编等），另一类用户并没有相关的空间属性信息。它使用的数据集有3种不同的形式：

*	（用户，用户位置，物品，评分）：每一条记录代表了某一个地点的用户对物品的评分。
*	（用户，物品，物品位置，评分）：每一条记录代表了用户对某个地方的物品的评分。
*	（用户，用户位置，物品，物品位置，评分）：每一条记录代表了某个位置的用户对某个位置的物品的评分。

LARS通过研究前两种数据集，发现了用户兴趣和地点相关的两种特征：

*	**兴趣本地化**：不同地方的用户兴趣存在着很大的差别。
*	**活动本地化**：一个用户往往在附近的地区活动。因此，在基于位置的推荐中我们需要考虑推荐地点和用户当前地点的距离，不能给用户推荐太远的地方。

对于第一种数据集，LARS的基本思想是将数据集根据用户的位置划分成很多子集。因为位置信息是一个树状结构，比如国家、省、市、县的结构。因此，数据集也会划分成一个树状结构。然后，给定每一个用户的位置，我们可以将他分配到某一个叶子节点中，而该叶子节点包含了所有和他同一个位置的用户的行为数据集。然后，LARS就利用这个叶子节点上的用户行为数据，通过ItemCF给用户进行推荐。

不过这样做的缺点是，每个叶子节点上的用户数量可能很少，因此他们的行为数据可能过于稀疏，从而无法训练出一个好的推荐算法。为此，可以从根节点出发，在到叶子节点的过程中，利用每个中间节点上的数据训练出一个推荐模型，然后给用户生成推荐列表。而最终的推荐结果是这一系列推荐列表的加权。这种算法又称为*金字塔模型*，而金字塔的深度影响了推荐系统的性能，因而深度是这个算法的一个重要指标。

对于第二种数据集，每条用户行为表示为四元组（用户、物品、物品位置、评分），表示了用户对某个位置的物品给了某种评分。对于这种数据集，LARS会首先忽略物品的位置信息，利用ItemCF算法计算用户u对物品i的兴趣，然后对物品i的位置对用户u的代价进行惩罚。

对于第三种数据集，我们应该保证推荐的物品应该距离用户当前位置比较近，在此基础上再通过用户的历史行为给用户推荐离他近切他会感兴趣的物品。

## 5.3 扩展阅读

# 第6章 利用社交网络数据

基于社交网络的推荐可以很好地模拟现实社会。

## 6.1 获取社交网络数据的途径

### 6.1.1 电子邮件

*	我们可以通过分析用户的联系人列表了解用户的好友信息，而且可以进一步通过研究两个用户之间的邮件往来频繁程度度量两个用户的熟悉程度
*	我们也可以通过邮箱后缀得到一定的社交关系信息

### 6.1.2 用户注册信息

### 6.1.3 用户的位置数据

在网页上最容易拿到的用户位置信息就是IP地址。对于手机等移动设备，我们可以拿到更详细的GPS数据。

### 6.1.4 讨论和讨论组

### 6.1.5 即时聊天工具

### 6.1.6 社交网站

#### 1. 社会图谱和兴趣图谱

## 6.2 社交网络数据简介

一般来说，有3种不同的社交网络数据：

*	**双向确认的社交网络数据**
*	**单向关注的社交网络数据**
*	**基于社区的社交网络数据**

### 社交网络数据中的长尾分布

在一个社交网络中，关注很多人的用户占少数，而绝大多数用户只关注很少的人。

## 6.3 基于社交网络的推荐

社会化推荐的优点：

*	**好友推荐可以增加推荐的信任度**
*	**社交网络可以解决冷启动问题**

### 6.3.1 基于领域的社会化推荐算法

推荐算法中需要考虑好友和用户的熟悉程度以及兴趣相似度

### 6.3.2 基于图的社会化推荐算法

### 6.3.3 实际系统中的社会化推荐算法

将Twitter的架构搬到社会化推荐系统中：

*	首先，为每个用户维护一个消息队列，用于存储他的推荐列表
*	当一个用户喜欢一个物品时，就将（物品ID、用户ID和时间）这条记录写入关注该用户的推荐列表消息队列中
*	当用户访问推荐系统时，读出他的推荐列表消息队列，对于这个消息队列中的每个物品，重新计算该物品的权重。计算权重时需要考虑物品在队列中出现的次数，物品对应的用户和当前用户的熟悉程度、物品的时间戳。同时，计算出每个物品被哪些好友喜欢过，用这些好友作为物品的推荐解释。

### 6.3.4 社会化推荐系统和协同过滤推荐系统

应该在自己的系统中进行AB测试，得到最为客观的答案。

### 6.3.5 信息流推荐

目前最流行的信息流推荐算法是Facebook的EdgeRank，该算法综合考虑了信息流中每个会话的时间、长度与用户兴趣的相似度。

## 6.4 给用户推荐好友

好友推荐系统的目的是根据用户现有的好友、用户的行为记录给用户推荐新的好友，从而增加整个社交网络的稠密程度和社交网站用户的活跃度。

好友推荐算法在社交网络中被称为链接预测（link prediction）。

### 6.4.1 基于内容的匹配

常用的内容属性：

*	常用人口统计学属性，包括年龄、性别、职业、毕业学校和工作单位等
*	用户的兴趣，包括用户喜欢的物品和发不过的言论等
*	用户的位置信息，包括用户的住址、IP地址和邮编等

利用内容信息计算用户的相似度和我们前面讨论的利用内容信息计算物品的相似度类似。

### 6.4.2 基于共同兴趣的好友推荐

### 6.4.3 基于社交网络图的好友推荐

#### 离线实验

### 6.4.4 基于用户调查的好友推荐算法对比

算法：

*	InterestBased：给用户推荐和他兴趣相似的其他用户作为好友
*	SocialBased：基于社交网络给用户推荐他好友的好友作为好友
*	Interest+Social：将InterestBased算法推荐的好友和SocialBased算法推荐的好友按照一定权重融合
*	SONA：SONA是IBM内部的推荐算法，该算法利用大量用户信息建立了IBM员工之间的社交网络。

## 6.5 扩展阅读

社交网络研究中有两个最著名的问题：

*	第一个是如何度量人的重要性，也就是社交网络顶点的中心度（centrality）
*	第二个问题是如何度量社交网络中人和人之间的关系，也就是链接预测

# 第7章 推荐系统实例

## 7.1 外围架构

目前流行的推荐系统界面共性：

*	通过一定方式展示物品，主要包括物品的标题、缩略图和介绍等
*	很多推荐界面都提供了推荐理由，理由可以增加用户对推荐结果的信任度
*	推荐界面还需要提供一些按钮让用户对推荐结果进行反馈，这样才能让推荐算法不断改善用户的个性化推荐体验

### 数据收集和存储

| 行为 | 用户类型 | 规模 | 实时存取 |
| ---- | ------- | --- | ------- |
| 浏览网页 | 注册/匿名 | 大 | 否 |
| 将商品加入购物车 | 注册 | 中 | 是 | 
| 购买商品 | 注册 | 中 | 是 |
| 收藏商品 | 注册 | 中 | 是 |
| 评论商品 | 注册 | 小 | 是 |
| 给商品评分 | 注册 | 小 | 是 |
| 搜索商品 | 注册/匿名 | 大 | 否 | 
| 点击搜索结果 | 注册/匿名 | 大 | 否 |
| 分享商品 | 注册 | 小 | 是 |

一般来说，需要实时存取的数据存储在数据库和缓存中，而大规模的非实时地存取数据存储在分布式文件系统（如HDFS）中。

## 7.2 推荐系统架构

推荐系统联系用户和物品的3种方式：

*	用户--（喜欢）--物品--（相似）--物品
*	用户--（有相似兴趣、好友）--用户--（喜欢）--物品
*	用户--（喜欢、具有）--特征--（包含）--物品

将这3种方式抽象一下就可以发现，如果认为用户喜欢的物品也是一种用户特征，或者和用户兴趣相似的其他用户也是一种用户特征，那么用户就和物品通过特征相联系。

根据上面的抽象，可以设计一种基于特征的推荐系统架构。当用户到来之后，推荐系统需要为用户生成特征，然后对每个特征找到和特征相关的物品，从而最终生成用户的推荐列表。

推荐系统的核心任务：

*	一个是如何为给定用户生成特征
*	另一个是如何根据特征找到物品

用户的特征种类：

*	**人口统计学特征**
*	**用户的行为特征**
*	**用户的话题特征**

推荐系统的多种推荐任务：

*	将新加入的物品推荐给用户
*	将商业上需要宣传的物品推荐给用户
*	给用户推荐不同种类的物品
*	给用户混合推荐
*	对于不同的产品推荐不同新颖度的物品
*	利用用户访问推荐系统的上下文推荐

推荐系统的架构图：

![](/img/notes/rs/recommenderSystemsPractice/rs_architecture.jpg)

## 7.3 推荐引擎的架构

推荐引擎架构的主要3部分：

*	第一部分负责从数据库或者缓存中拿到用户行为数据，通过分析不同行为，生成当前用户的特征向量。不过如果是使用非行为特征，就不需要使用行为提取和分析模块了。该模块的输出是用户特征向量。
*	第二部分负责将用户的特征向量通过特征-物品相关矩阵转化为初始推荐物品列表。
*	第三部分负责对初始的推荐列表进行过滤、排名等处理，从而生成最终的推荐结果。

### 7.3.1 生成用户特征向量

两种用户特征：

*	用户的注册信息中提取出来
*	从用户的行为中计算出来

在利用用户行为计算特征向量时需要考虑以下因素：

*	**用户行为的种类**
*	**用户行为产生的时间**
*	**用户行为的次数**
*	**物品的热门程度**

### 7.3.2 特征-物品相关推荐

存储格式：

*	特征ID
*	物品ID
*	权重

### 7.3.3 过滤模块

过滤模块会过滤掉以下物品：

*	**用户已经产生过行为物品**
*	**候选物品以外的物品**：不满足产品需求的物品、不满足用户需求的物品
*	**某些质量很差的物品**

### 7.3.4 排名模块

#### 1. 新颖性排名

新颖性排名模块的目的是给用户尽量推荐他们不知道的、长尾中的物品。

方法：对热门物品进行降权

#### 2. 多样性

多样性也是推荐系统的重要指标之一。增加多样性可以让推荐结果覆盖尽可能多的用户兴趣。

方法：

*	将推荐结果按照某种物品的内容属性分成几类，然后在每个类中都选择该类中排名最高的物品组合成最终的推荐列表。优点：简单直观；缺点：选择什么样的内容属性进行分类对结果的影响很大，其次，就算选择了某种类别，但物品是否属于某个类别是编辑确定的，并不一定能够得到用户的公认。
*	控制不同推荐结果的推荐理由出现的次数。提高推荐结果的多样性，就需要让推荐结果尽量来自不同的特征，具有不同的推荐理由，而不是所有的推荐结果都对应一个理由。

#### 3. 时间多样性

时间多样性主要是为了保证用户不要每天来推荐系统都看到同样的推荐结果。

*	首先要保证推荐系统的实时性
*	第二个方面是要在用户没有新的行为时，也要保证推荐结果每天都有变化。

要实现第二个方面，只能通过如下方式：

*	记录用户每次登陆推荐系统看到的推荐结果
*	将这些结果发回日志系统。这种数据不需要实时存储，只要能保证小于一天的延时就足够了
*	在用户登录时拿到用户昨天及之前看过的推荐结果列表，从当前推荐系统中将用户已经看到的推荐结果降权

#### 4. 用户反馈

排名模块最重要的部分就是用户反馈模块。用户反馈模块主要通过分析用户之前和推荐结果的交互日志，预测用户会对什么样的推荐结果比较感兴趣。

在推荐系统的点击率预测中可以用如下特征预测用户会不会点击物品：

*	用户相关的特征，比如年龄、性别、活跃程度、之前有没有点击行为；
*	物品相关的特征，比如流行度，平均分，内容属性；
*	物品在推荐列表中的位置
*	用户之前是否点击过和推荐物品具有同样推荐解释的其他推荐结果
*	用户之前是否点击过和推荐物品来自同样推荐引擎的其他推荐结果

点击模型需要离线计算好，在线将模型加载到内存中。为了提高在线预测的效率，一般只可以使用线性模型。

# 第8章 评分预测问题

## 8.1 离线实验方法

Netflix通过如下方式划分数据集，首相将每个用户的评分记录按照从早到晚进行排序，然后将用户最后10%的评分记录作为测试集，前90%的评分记录作为训练集。

## 8.2 评分预测算法

### 8.2.1 平均值

#### 1. 全局平均值

#### 2. 用户评分平均值

#### 3. 物品评分平均值

#### 4. 用户分类对物品分类的平均值

### 8.2.2 基于领域的方法

### 8.2.3 隐语义模型与矩阵分解模型

通过降维的方法将评分矩阵补全

### 8.2.4 加入时间信息

#### 1. 基于领域的模型融合时间信息

#### 2. 基于矩阵分解的模型融合时间信息

### 8.2.5 模型融合

#### 1. 模型级联融合

#### 2. 模型加权融合

### 8.2.6 Netflix Prize的相关实验结果

# 后记

10条经验和教训：

1.	确定你真的需要推荐系统。推荐系统只有在用户遇到信息过载时才必要。如果你的网站物品不太多，或者用户兴趣都比较单一，那么也许并不需要推荐系统。所以不要纠结于推荐系统这个词，不要为了做推荐系统而作推荐系统，而是应该从用户的角度出发，设计出能够真正帮助用户发现内容的系统，无论这个系统推荐算法是否复杂，只要能够真正棒喝足用户，就是一个好的系统。
2.	确定商业目标和用户满意度之间的关系。对用户好的推荐系统不代表商业上有用的推荐系统，因此要首先确定用户满意的推荐系统和商业上需求的差距。一般来说，有些时候用户满意和商业需求并不吻合。但是一般情况下，用户满意度总是符合企业的长期利益，因此这一跳的主要观点是要平衡企业的长期利益和短期利益之间的关系。
3.	选择合适的开发人员。一般来说，如果是一家大公司，应该雇佣自己的开发人员来专门进行推荐系统的开发。
4.	忘记冷启动的问题。不断的创新，互联网上有任何你想要的数据。只要用户喜欢你的产品，他们就会不断贡献新的数据。
5.	平衡数据和苏阿凡纳之间的关系。使用正确的用户数据对推荐系统至关重要。对用户行为数据的深刻理解是设计好推荐系统的必要条件，因此分析数据是设计推荐系统中最重要的部分。数据分析决定了如图喝设计模型，而算法只是决定了如何优化模型。
6.	找到相关的物品很容易，但是如何以何种方式将他们展现给用户是很困难的。不要为了推荐而推荐。
7.	不要浪费时间计算相似兴趣的用户，可以直接利用社会网络
8.	需要不断的提升算法的拓展性
9.	选择合适的用户反馈方式
10.	设计合理的评测系统, 时刻关注推荐系统各个方面的性能