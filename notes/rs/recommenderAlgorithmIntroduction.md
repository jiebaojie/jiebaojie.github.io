---
layout: post
notes: true
subtitle: "【技术博客】推荐算法综述"
comments: false
author: " 百占辉"
date: 2018-01-19 00:00:00

---


原文：

[http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01)

[http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part02](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part02)

[http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part03](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part03)

[http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part04](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part04)

[http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part05](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part05)


*   目录
{:toc }

注：本文翻译自[Building Recommenders](https://buildingrecommenders.wordpress.com/)，InfoQ中文站在获得作者授权的基础上对文章进行了翻译。

为推荐系统选择正确的推荐算法是非常重要的决定。目前为止，已经有许多推荐算法可供选择，但为你需要解决的特定问题选择一种特定的算法仍然很困难。每一种推荐算法都有其优点和缺点，当然也有其限制条件，在作出决定之前，你必须要一一考量。在实践中，你可能会测试几种算法，以发现哪一种最适合你的用户，测试中你也会直观地发现它们是什么以及它们的工作原理。

推荐系统算法通常是某类推荐模型的实现，它负责获取数据，例如用户的喜好和可推荐项的描述，以及预测给定的用户组会对哪些选项感兴趣。

推荐算法通常被分为几大类：

*	协同过滤推荐算法
*	基于内容的推荐算法
*	混合推荐算法
*	流行度推荐算法
*	高级非传统的推荐算法

# 第一篇 推荐算法的主要种类

## 1. 协同过滤推荐算法

*	简介：通过在用户的一系列行为中寻找特定模式来产生用户特殊推荐
*	输入：仅仅依赖于惯用数据（例如评价、购买、下载等用户偏好行为）
*	类型：
	*	基于邻域的协同过滤（基于用户和基于项）
	*	基于模型的协同过滤（矩阵因子分解、受限玻尔兹曼机、贝叶斯网络等等）
*	优点：
	*	需要最小域
	*	不需要用户和项
	*	大部分场景中能够产生足够好的结果
*	缺点：
	*	冷启动问题
	*	需要标准化产品
	*	需要很高的用户和项的比例（1：10）
	*	流行度偏见（有长尾的时候表现不够好）
	*	难于提供解释
	
## 2. 基于内容的推荐算法

*	简介：向用户推荐和其过去喜欢项的内容（例如元数据、描述、话题等等）相似的项
*	输入：仅仅依赖于项和用户的内容/描述（除了惯用数据）
*	类型：
	*	信息检索（例如 tf-idf 和 Okapi BM25）
	*	机器学习（例如朴素贝叶斯、支持向量机、决策树等等）
*	优点：
	*	没有冷启动问题
	*	不需要惯用数据
	*	没有流行度偏见，可以推荐有罕见特性的项
	*	可以使用用户内容特性来提供解释
*	缺点：
	*	项内容必须是机器可读的和有意义的
	*	容易归档用户
	*	很难有意外，缺少多样性
	*	很难联合多个项的特性
	
## 3. 混合推荐算法

*	简介：综合利用协同过滤推荐算法和基于内容的推荐算法各自的优点同时抵消各自的缺点
*	输入：同时使用用户和项的内容特性与惯用数据，同时从两种输入类型中获益
*	类型：
	*	加权
	*	交换
	*	混合
	*	特性组合
	*	案例
	*	特征增强
	*	元层次
*	优点：
	*	由于单独使用协同过滤推荐算法和基于内容的推荐算法
	*	没有冷启动问题
	*	没有流行度偏见，可推荐有罕见特性的项
	*	可产生意外，实现多样性
*	缺点：
	*	需要通过大量的工作才能得到正确的平衡
	
## 4. 流行度推荐算法

*	简介：这是一种推荐流行项的方法（例如最多下载、最多看过、最大影响的项）
*	输入：使用惯用数据和项的内容（例如类目）
*	优点：
	*	相对容易实现
	*	良好的基准算法
	*	有助于解决新用户冷启动问题
*	缺点：
	*	需要标准化产品
	*	经常需要一些项的类型进行分类
	*	不会推荐新项（很少有机会被观测到）
	*	推荐列表不会改变太大
	
## 5. 高级非传统推荐算法

*	类型：
	*	深度学习
	*	学习等级
	*	Multi-armed bandits（探索/开发）
	*	上下文感知推荐
	*	张量分解
	*	分解机
	*	社会推荐
*	优点：
	*	利于勉强维持最终性能百分点
	*	你可以说你正在使用渐进的方式
*	缺点：
	*	难于理解
	*	缺乏推荐工具支持
	*	没有为你的首个推荐系统提供推荐的方式
	
# 第二篇 协同过滤推荐算法以及其优点和缺点

协同过滤（CF）推荐算法通过在用户活动中寻找特定模式来为用户产生有效推荐。它依赖于系统中用户的惯用数据，例如通过用户对其阅读过书籍的评价可以推断出用户的阅读偏好。

核心思想：如果两个用户对于一些项的评分相似程度较高，那么一个用户对于一个新项的评分很有可能类似于另一个用户。

值得注意的是，他们推荐的时候不依赖于项的任何附加信息（例如描述、元数据等等）或者用户的任何附加信息（例如喜好、人口统计相关数据等等）。

CF的方法大体可分为两类：

*	邻域方法（即基于内存的CF）：使用用户对已有项的评分直接预测该用户对新项的评分
*	基于模型的方法：使用历史评分数据，基于学习出的预测模型，预测对新项的评分。通常的方式是使用机器学习算法，找出用户与项的相互作用模型，从而找出数据中的特定模式。

基于邻域的CF方法意在找出项与项之间的联系（基于项的CF），或者用户与用户之间的联系（基于用户的CF）：

*	基于用户的CF通过找出对项的偏好与你相似的用户从而基于他们对于新项的喜好来为你进行推荐。
*	基于项的CF会向用户推荐与用户喜欢的项相似的项，这种相似是基于项的共同出现几率（例如用户买了X，同时也买了Y）。

鉴于基于用户和基于项的协同过滤的描述听起来非常相似，有趣的是它们可以产生不同的推荐结果。

当你构建推荐系统的时候，这两种协同过滤方式都是值得考虑的。即使将这两种方式描述给非专家听，它们听起来也非常相似，在实践中，他们可以产生不同的结果，为用户提供了不同的体验。

邻域方法由于其简单性和效率具有相当的知名度，同时也是由于它们有产生准确的和个性化的推荐的能力。然而，它们也有一些可扩展性的限制，因为在用户数量和项的数量增长的情况下，它们需要一个相似度的计算（基于用户或项）。在最坏的情况下，这种计算的时间复杂度可能是O(m*n)，但在实践中的情况稍微好一点O(m+n)，部分原因是由于利用了数据的稀疏度。虽然稀疏有助于可扩展性，它也对基于邻域的方法提出了一个挑战，因为我们的用户仅仅对庞大数量项中的很少一部分进行了评分。例如，在Mendeley，我们有数以百万计的文章而一个用户可能只读了其中几百篇文章。两个读过100篇文章的用户有一篇相同文章的概率（共5000万篇文章）是0.0002。

基于模型的方法可以帮助克服一些基于邻域的方法的局限性。它不像基于邻域的方法，使用用户项评分直接预测新的项。基于模型的方法会在使用评分去学习预测模型的基础上，去预测新项。一般的想法是使用机器学习算法建立用户和项的相互作用模型，从而找出数据中的模式。在一般情况下，基于模型的CF被认为是建立CF推荐系统的更先进的算法。有许多不同的算法可用于构建模型并基于这些模型进行预测，例如，贝叶斯网络、聚类、分类、回归、矩阵分解、受限玻尔兹曼机等等。这些技术在为了最终赢得Netflix奖的解决方案中扮演了关键角色。

矩阵因子分解（如奇异值分解，奇异值分解+ +）将项和用户都转化成了相同的潜在空间，它所代表了用户和项之间的潜相互作用。矩阵分解背后的原理是潜在特征代表了用户如何给项进行评分。给定用户和项的潜在描述，我们可以预测用户将会给还未评价的项多少评分。

优点：由于它们仅依赖于用户的惯用数据，协同过滤方法需要最低限度专业工程的努力，以产生足够好的结果。

缺点：CF倾向于推荐流行的项，很难推荐给有独特口味的人（即感兴趣的项并没有产生足够多的惯用数据）。这被称为流行性偏见，它通常是用基于内容的过滤方法。CF方法的一个更重要的限制是我们所称的“冷启动问题”，系统是不能够给没有（或非常少）惯用活动的用户进行推荐，又名曰新用户问题，或推荐新项问题。新用户的“冷启动问题”可以通过流行性和混合方法进行解决，而新项问题可以通过使用基于内容的过滤或multi-armed bandits（即探索利用）进行解决。

# 第三篇 基于内容的过滤算法以及其优点和缺点

基于内容的推荐算法总是为用户推荐那些与用户过去喜欢的item类似的item。它不同于协同过滤，它是基于item的内容（例如标题、年份、描述）比较item之间的相似度。并没有考虑用户过去如何使用item的情况。

在基于内容的推荐中，假设可以获取到item的描述信息，并将其作为item的特征向量（例如标题、年份、描述）。这些特征向量被用于创建一个反映用户偏好的模型。各种信息检索（例如TF-IDF）和机器学习技术（例如朴素贝叶斯、支持向量机、决策树等）可被用于创建用户模型，从而为用户产生推荐。

基于内容的方法克服了协同过滤方法的很多不足。具体来说，基于内容的推荐算法可以克服流行度偏离和新item的冷启动问题，这些问题在第二部分介绍协同过滤的时候已经讨论过。然而，值得注意的是，纯粹基于内容的推荐算法的性能通常不如协同过滤算法。基于内容的推荐算法通常还存在过度专业化（over-specialisation）的问题，即用户可能会得到过多相同类型的item（如推荐所有的“指环王”系列电影），而不会推荐其他不同的、但用户可能感兴趣的item。最后是，基于内容的推荐算法中，仅仅使用了包含在item元数据中的词汇（如标题、描述年份），这限制了推荐算法的实用性，不能帮助用户探索和发现词汇之外的内容。

# 第四篇 混合推荐技术

简要讨论针对协同过滤算法（collaborative filtering，CF）和基于内容的过滤方法中存在的不足，可以如何通过融入item的流行度来缓解这些局限性。

混合方法组合了用户和项目内容特征以及用户的历史行为数据，从而从两种数据中提取信息。一个混合推荐系统如果结合了算法A和B，那么它是希望使用算法A的优势来解决算法B的缺点。例如，协同过滤算法存在新item的问题，即它们不能为用户推荐所有用户没有使用过或评分过item。但这对基于内容的推荐算法来说并不是问题，因为当新的item进入系统的时候，基于内容的推荐算法可以基于item的内容推荐新的item给用户。通过提出一个混合推荐方法，让其组合协同过滤算法和基于内容的过滤算法，可以克服单个算法存在的不足，例如冷启动问题和流行度偏差问题。

然混合方法解决CF方法和CB方法中存在的一些局限性，但它们同时也需要大量的工作来获取系统中的不同算法之间的平衡。组合单个的推荐算法的另一种技术是集成方法，它需要学习一个函数（即集成器）来确定不同推荐算法组合的权重。值得注意的是，通常集成方法不仅仅结合了不同的算法，同时也组合了基于相同算法的不同变种（模型）。

基于流行度的方法对于新用户的冷启动问题也是一个很好的解决方法。这种方法在对item进行评分时使用某种形式流行度度量，例如最多的下载次数或购买量，然后向新用户推荐这些受欢迎的item。当你有一个好的流行度度量的时候，这是一个基本的、但功能强大的方法，而且在与其他推荐算法进行比较时提供一个好的基线。在可以切换到其他能够更好地建模用户偏好的方法（协同过滤技术和基于内容的过滤技术）之前，流行度度量本身可以作为一种算法来增强一个推荐系统，以获得足够的活跃度和使用量。流行度的模型也可以组合在混合方法中，以帮助解决推荐系统的新用户冷启动问题。

# 第五篇 如何选择最合适的推荐算法

目前还有许多的其他方法也可以用于增强推荐系统，包括：

*	深度学习
*	社会化推荐
*	学习排序
*	多臂Bandit（探索/利用）
*	张量因子分解和因子分解（情境感知的推荐）

这些更先进的和非传统的方法有利于将推荐系统的性能推高到一个新的水平，但实际上这些算法也存在不足，不太易于理解，而且在推荐插件中并没有很好地被支持。在实际应用中，相比一些更传统的方法而言，用户还需要考量执行更新的方法所带来的性能提升是否值得算法所花费的开销。根据我们的经验，基本的传统算法还将在实际系统中应用很久，并还将驱动一些伟大的产品的诞生。

在实际应用中，如果你利用协同过滤算法作为你的推荐模型，一般不会出什么问题。协同过滤容易比其他算法产生更好的结果，但是它不能很好地处理新用户和新item的冷启动问题，如果要处理这些问题，基于内容的推荐算法是一个很好的备选。如果你有时间，那么可以将这些方法进行组合，这样你就可以同时利用协同过滤算法和基于内容的推荐算法的优点。即使需要考察更为先进的推荐算法，在此之前，先好好考虑一下这些基本的算法也不失为一个好主意。

最后，需要紧紧牢记的是，推荐模型仅仅是推荐系统五个部件中的其中一个。付出努力将推荐模型正确建立起来是非常重要的，但是对于其他的所有部件，如数据收集和处理、后处理、在线模块和用户界面，做出正确的选择同样重要。正如我们一遍又一遍所强调的，该推荐算法仅仅是推荐系统中的一部分，你的决策需要考虑整个产品。