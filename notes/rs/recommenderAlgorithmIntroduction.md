---
layout: post
notes: true
subtitle: "【技术博客】推荐算法综述"
comments: false
author: "高小倩"
date: 2018-1-19 00:00:00

---


原文：

[http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01)

[http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part02](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part02)

[http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part03](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part03)

[http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part04](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part04)

[http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part05](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part05)


*   目录
{:toc }

注：本文翻译自[Building Recommenders](https://buildingrecommenders.wordpress.com/)，InfoQ中文站在获得作者授权的基础上对文章进行了翻译。

为推荐系统选择正确的推荐算法是非常重要的决定。目前为止，已经有许多推荐算法可供选择，但为你需要解决的特定问题选择一种特定的算法仍然很困难。每一种推荐算法都有其优点和缺点，当然也有其限制条件，在作出决定之前，你必须要一一考量。在实践中，你可能会测试几种算法，以发现哪一种最适合你的用户，测试中你也会直观地发现它们是什么以及它们的工作原理。

推荐系统算法通常是某类推荐模型的实现，它负责获取数据，例如用户的喜好和可推荐项的描述，以及预测给定的用户组会对哪些选项感兴趣。

推荐算法通常被分为几大类：

*	协同过滤推荐算法
*	基于内容的推荐算法
*	混合推荐算法
*	流行度推荐算法
*	高级非传统的推荐算法

# 第一篇 推荐算法的主要种类

## 1. 协同过滤推荐算法

*	简介：通过在用户的一系列行为中寻找特定模式来产生用户特殊推荐
*	输入：仅仅依赖于惯用数据（例如评价、购买、下载等用户偏好行为）
*	类型：
	*	基于邻域的协同过滤（基于用户和基于项）
	*	基于模型的协同过滤（矩阵因子分解、受限玻尔兹曼机、贝叶斯网络等等）
*	优点：
	*	需要最小域
	*	不需要用户和项
	*	大部分场景中能够产生足够好的结果
*	缺点：
	*	冷启动问题
	*	需要标准化产品
	*	需要很高的用户和项的比例（1：10）
	*	流行度偏见（有长尾的时候表现不够好）
	*	难于提供解释
	
## 2. 基于内容的推荐算法

*	简介：向用户推荐和其过去喜欢项的内容（例如元数据、描述、话题等等）相似的项
*	输入：仅仅依赖于项和用户的内容/描述（除了惯用数据）
*	类型：
	*	信息检索（例如 tf-idf 和 Okapi BM25）
	*	机器学习（例如朴素贝叶斯、支持向量机、决策树等等）
*	优点：
	*	没有冷启动问题
	*	不需要惯用数据
	*	没有流行度偏见，可以推荐有罕见特性的项
	*	可以使用用户内容特性来提供解释
*	缺点：
	*	项内容必须是机器可读的和有意义的
	*	容易归档用户
	*	很难有意外，缺少多样性
	*	很难联合多个项的特性
	
## 3. 混合推荐算法

*	简介：综合利用协同过滤推荐算法和基于内容的推荐算法各自的优点同时抵消各自的缺点
*	输入：同时使用用户和项的内容特性与惯用数据，同时从两种输入类型中获益
*	类型：
	*	加权
	*	交换
	*	混合
	*	特性组合
	*	案例
	*	特征增强
	*	元层次
*	优点：
	*	由于单独使用协同过滤推荐算法和基于内容的推荐算法
	*	没有冷启动问题
	*	没有流行度偏见，可推荐有罕见特性的项
	*	可产生意外，实现多样性
*	缺点：
	*	需要通过大量的工作才能得到正确的平衡
	
## 4. 流行度推荐算法

*	简介：这是一种推荐流行项的方法（例如最多下载、最多看过、最大影响的项）
*	输入：使用惯用数据和项的内容（例如类目）
*	优点：
	*	相对容易实现
	*	良好的基准算法
	*	有助于解决新用户冷启动问题
*	缺点：
	*	需要标准化产品
	*	经常需要一些项的类型进行分类
	*	不会推荐新项（很少有机会被观测到）
	*	推荐列表不会改变太大
	
## 5. 高级非传统推荐算法

*	类型：
	*	深度学习
	*	学习等级
	*	Multi-armed bandits（探索/开发）
	*	上下文感知推荐
	*	张量分解
	*	分解机
	*	社会推荐
*	优点：
	*	利于勉强维持最终性能百分点
	*	你可以说你正在使用渐进的方式
*	缺点：
	*	难于理解
	*	缺乏推荐工具支持
	*	没有为你的首个推荐系统提供推荐的方式
	
# 第二篇 协同过滤推荐算法以及其优点和缺点

协同过滤（CF）推荐算法通过在用户活动中寻找特定模式来为用户产生有效推荐。它依赖于系统中用户的惯用数据，例如通过用户对其阅读过书籍的评价可以推断出用户的阅读偏好。

核心思想：如果两个用户对于一些项的评分相似程度较高，那么一个用户对于一个新项的评分很有可能类似于另一个用户。

值得注意的是，他们推荐的时候不依赖于项的任何附加信息（例如描述、元数据等等）或者用户的任何附加信息（例如喜好、人口统计相关数据等等）。

CF的方法大体可分为两类：

*	邻域方法（即基于内存的CF）：使用用户对已有项的评分直接预测该用户对新项的评分
*	基于模型的方法：使用历史评分数据，基于学习出的预测模型，预测对新项的评分。通常的方式是使用机器学习算法，找出用户与项的相互作用模型，从而找出数据中的特定模式。

基于邻域的CF方法意在找出项与项之间的联系（基于项的CF），或者用户与用户之间的联系（基于用户的CF）：

*	基于用户的CF通过找出对项的偏好与你相似的用户从而基于他们对于新项的喜好来为你进行推荐。
*	基于项的CF会向用户推荐与用户喜欢的项相似的项，这种相似是基于项的共同出现几率（例如用户买了X，同时也买了Y）。

鉴于基于用户和基于项的协同过滤的描述听起来非常相似，有趣的是它们可以产生不同的推荐结果。

当你构建推荐系统的时候，这两种协同过滤方式都是值得考虑的。即使将这两种方式描述给非专家听，它们听起来也非常相似，在实践中，他们可以产生不同的结果，为用户提供了不同的体验。

邻域方法由于其简单性和效率具有相当的知名度，同时也是由于它们有产生准确的和个性化的推荐的能力。然而，它们也有一些可扩展性的限制，因为在用户数量和项的数量增长的情况下，它们需要一个相似度的计算（基于用户或项）。在最坏的情况下，这种计算的时间复杂度可能是O(m*n)，但在实践中的情况稍微好一点O(m+n)，部分原因是由于利用了数据的稀疏度。虽然稀疏有助于可扩展性，它也对基于邻域的方法提出了一个挑战，因为我们的用户仅仅对庞大数量项中的很少一部分进行了评分。例如，在Mendeley，我们有数以百万计的文章而一个用户可能只读了其中几百篇文章。两个读过100篇文章的用户有一篇相同文章的概率（共5000万篇文章）是0.0002。

基于模型的方法可以帮助克服一些基于邻域的方法的局限性。它不像基于邻域的方法，使用用户项评分直接预测新的项。基于模型的方法会在使用评分去学习预测模型的基础上，去预测新项。一般的想法是使用机器学习算法建立用户和项的相互作用模型，从而找出数据中的模式。在一般情况下，基于模型的CF被认为是建立CF推荐系统的更先进的算法。有许多不同的算法可用于构建模型并基于这些模型进行预测，例如，贝叶斯网络、聚类、分类、回归、矩阵分解、受限玻尔兹曼机等等。这些技术在为了最终赢得Netflix奖的解决方案中扮演了关键角色。

矩阵因子分解（如奇异值分解，奇异值分解+ +）将项和用户都转化成了相同的潜在空间，它所代表了用户和项之间的潜相互作用。矩阵分解背后的原理是潜在特征代表了用户如何给项进行评分。给定用户和项的潜在描述，我们可以预测用户将会给还未评价的项多少评分。

优点：由于它们仅依赖于用户的惯用数据，协同过滤方法需要最低限度专业工程的努力，以产生足够好的结果。

缺点：CF倾向于推荐流行的项，很难推荐给有独特口味的人（即感兴趣的项并没有产生足够多的惯用数据）。这被称为流行性偏见，它通常是用基于内容的过滤方法。CF方法的一个更重要的限制是我们所称的“冷启动问题”，系统是不能够给没有（或非常少）惯用活动的用户进行推荐，又名曰新用户问题，或推荐新项问题。新用户的“冷启动问题”可以通过流行性和混合方法进行解决，而新项问题可以通过使用基于内容的过滤或multi-armed bandits（即探索利用）进行解决。