---
layout: post
notes: true
subtitle: "Spring Microservices IN ACTION"
comments: false
author: "[美] John Camell （陈文辉 译）"
date: 2018-06-27 00:00:00

---

![](/img/notes/architect/springMicroservicesInAction/spring_microservices_in_action.jpg)

*   目录
{:toc }

# 第1章 欢迎迈入云世界，Spring

本章主要内容：

*	了解微服务以及很多公司使用微服务的原因
*	使用Spring、Spring Boot和Spring Cloud来搭建微服务
*	了解云和微服务为什么与基于微服务的应用程序有关
*	构建微服务涉及的不只是构建微服务代码
*	了解基于云的开发的各个组成部分
*	在微服务开发中使用Spring Boot和Spring Cloud

## 1.1 什么是微服务

微服务是一个小的、松耦合的分布式服务。微服务允许将一个大型的应用分解为具有严格职责定义的便于管理的组件。微服务通过将大型代码分解为小型的精确定义的部分，帮助解决大型代码库中传统的复杂问题。在思考微服务时，一个需要信奉的重要概念就是：分解和分离应用程序的功能，使它们完全彼此独立。

微服务架构具有以下特征：

*	应用程序逻辑分解为具有明确定义了职责范围的细粒度组件，这些组件互相协调提供解决方案
*	每个组件都有一个小的职责领域，并且完全独立部署。微服务应该对业务领域的单个部分负责。此外，一个微服务应该可以跨多个应用程序复用。
*	微服务通信基于一些基本的原则（注意，我说的是原则而不是标准），并采用HTTP和JSON（JavaScript Object Notation）这样的轻量级通信协议，在服务消费者和服务提供者之间进行数据交换。
*	服务的底层采用什么技术实现并没有什么影响，因为应用程序始终使用技术中立的协议（JSON是最常见的）进行通信。这意味着构建在微服务之上的应用程序能够使用多种编程语言和技术进行构建。
*	微服务利用其小、独立和分布式的性质，使组织拥有明确责任领域的小型开发团队。这些团队可能为同一个目标工作，如交付一个应用程序，但是每个团队只负责它们在做的服务。

## 1.2 什么是Spring，为什么它与微服务有关

Spring在应用程序的不同的Java类之间充当一个中间人，管理着它们的依赖关系。Spring本质上就是让用户像玩乐高积木一样将自己的代码组装在一起。

Spring Boot是对Spring框架理念重新思考的结果。虽然Spring Boot包含了Spring的核心特性，但它剥离了Spring中的许多“企业”特性，而提供了一个基于Java的、面向REST的微服务框架。只需一些简单的注解，Java开发者就能够快速构建一个可打包和部署的REST微服务，这个微服务并不需要外部的应用容器。

Spring Cloud框架使实施和部署微服务到私有云或公有云变得更加简单。Spring Cloud在一个公共框架之下封装了多个流行的云管理微服务框架，并且让这些技术的使用和部署像为代码添加注解一样简便。

## 1.3 在本书中读者会学到什么

*	微服务是什么以及构建基于微服务的应用程序的设计考虑因素。
*	什么时候不应该构建基于微服务的应用程序
*	如何使用Spring Boot框架来构建微服务
*	支持微服务应用程序的核心运维模式，特别是基于云的应用程序
*	如何使用Spring Cloud来实现这些运维模式
*	如何利用所学到的知识，构建一个部署管道，将服务部署到内部管理的私有云或公有云厂商所提供的环境中

## 1.4 为什么本书与你有关

## 1.5 使用Spring Boot来构建微服务

## 1.6 为什么要改变构建应用的方式

*	复杂性上升
*	客户期待更快速的交付
*	性能和可伸缩性
*	客户期望他们的应用程序可用

悖论：构建高可伸缩性和高度冗余的应用程序。我们需要将应用程序分解成可以互相独立构建和部署的小型服务。如果将应用程序“分解”为小型服务，并将它们从单体制品中转移出来，那么久可以构建具有下面这些特性的系统。

*	灵活性——可以将解耦的服务进行组合和重新安排，以快速交付新的功能
*	有弹性——解耦的服务意味着应用程序不再是单个“泥浆球”，在这种架构中其中一部分应用程序的降级导致整个应用程序失败。
*	可伸缩性——解耦的服务可以轻松地跨多个服务器进行水平分布，从而可以适当地对功能/服务进行伸缩。

为此，当我们开始讨论微服务时，请记住下面一句话：*小型的、简单的和解耦的服务=可伸缩的、有弹性的和灵活的应用程序。*

## 1.7 云到底是什么

云计算有3种基本模式：

*	基础设施即服务（Infrastructure as a Service, IaaS）
*	平台即服务（Platform as a Service, Paas）
*	软件即服务（Software as a Service, Saas）

每个模型种的关键项都是控制：由谁来负责维护基础设施，以及构建应用程序的技术选择是什么？在Iaas模型中，云供应商提供基础设施，但你需要选择技术并构建最终的解决方案；而在SaaS模型中，你就是供应商所提供的服务的被动消费者，无法对技术进行选择，同时也没有任何责任来维护应用程序的基础设施。

新兴的云平台：

*	函数即服务（Functions as a Service, FaaS）：基于FaaS的应用程序会使用像亚马逊的Lambda技术和Google Cloud函数这样的设施，应用会将代码块以“无服务器（serverless）的形式部署，这些代码会完全在云提供商的平台计算设施上运行。使用FaaS平台，无需管理任何服务器基础设施，只需支付执行函数所需的计算周期。
*	容器即服务（Container as a Service, Caas）：使用容器即服务模型，开发人员将微服务作为便携式容器（如Docker）进行构建并部署到云供应商。CaaS是将服务部署在轻量级的虚拟容器中。云供应商会提供运行容器的虚拟服务器，以及用于构建、部署、监控和伸缩容器的综合工具。

需要重点注意的是，使用云计算的FaaS和CaaS模型，开发人员仍然可以构建基于微服务的架构。微服务概念的重点在于构建有限职责的小型服务，并使用基于HTTP的接口进行通信。新兴的云计算平台（如FaaS和CaaS）是部署微服务的替代基础设施机制。

## 1.8 为什么是云和微服务

基于云的微服务的优势是以弹性的概念为中心。云服务供应商允许开发人员在几分种内快速启动新的虚拟机和容器。如果服务器容量需求下降，开发人员可以关闭虚拟服务器，而不会产生任何额外的费用。使用云供应商部署微服务可以显著地提高应用程序的水平可伸缩性（添加更多的服务器和服务实例）。服务器弹性也意味着应用程序可以更具弹性。如果其中一台微服务遇到问题并且处理能力正在不断地下降，那么启动新的服务实例可以让应用程序保持足够长的存活时间，让开发团队能够从容而优雅地解决问题。

用于微服务的常见部署拓扑结构：

*	简化的基础设施管理——IaaS云计算供应商可以让开发人员最有效地控制他们的服务。开发人员可以通过简单的API调用来启动和停止新服务。
*	大规模的水平可伸缩性——IaaS云服务供应商允许开发人员快速简便地启动服务的一个或多个实例。
*	通过地理分布实现高冗余——Iaas供应商必然拥有多个数据中心。

## 1.9 微服务不只是编写代码

编写健壮的服务需要考虑几个主题：

*	大小适当——适当的大小允许快速更改应用程序，并降低整个应用程序中断的总体风险。
*	位置透明——在微服务应用程序中，多个服务实例可以快速启动和关闭时，如何管理服务调用的物理细节？
*	有弹性——如何通过绕过失败的服务，确保采取”快速失败“的方法来保护微服务消费者和应用程序的整体完整性？
*	可重复——如何确保提供的每个新服务实例与生产环境中的所有其他服务实例具有相同的配置和代码库？
*	可伸缩——如何使用异步处理和事件来最小化服务之间的直接依赖关系，并确保可以优雅地扩展微服务？

本书涵盖以下6类微服务模式：

*	核心微服务开发模式
*	微服务路由模式
*	微服务客户端弹性模式
*	微服务安全模式
*	微服务日志记录和跟踪模式
*	微服务构建和部署模式

### 1.9.1 核心微服务开发模式

基本服务设计的主题：

*	服务粒度——如何将业务域分解为微服务，使每个微服务都具有适当成都的职责？
*	通信协议——开发人员如何与服务进行通信？
*	接口设计——如何设计实际的服务接口，便于开发人员进行服务调用？
*	服务的配置管理——如何管理微服务的配置，以便在不同云环境之间移动时，不必更改核心应用程序代码或配置？
*	服务之间的时间处理——如何使用事件解耦微服务，以便最小化服务之间的硬编码依赖关系，并提高应用程序的弹性？

### 1.9.2 微服务路由模式

*	服务发现——如何使微服务变得可以被发现，以便客户端应用程序在不需要将服务的位置硬编码到应用程序的情况下找到它们？如何确保从可用的服务实例池中删除表现不佳的微服务实例？
*	服务路由——如何为所有服务提供单个入口点，以便将安全策略和路由规则统一应用于微服务应用程序中的多个服务和服务实例？如何确保团队中的每位开发人员不必为他们的服务提供自己的服务路由解决方案？

我们可以实现没有服务路由的服务发现，也可以实现服务路由而无需服务发现（尽管这种实现更加困难）

### 1.9.3 微服务客户端弹性模式

4种客户端弹性模式：

*	客户端负载均衡——如何在服务客户端上缓存服务实例的位置，以便对微服务的多个实例的调用负载均衡到该微服务的所有健康实例？
*	断路器模式——如何阻止客户继续调用出现故障的或遭遇性能问题的服务？
*	后备模式——当服务调用失败时，如何提供”插件“机制，允许服务的客户端尝试通过调用微服务之外的其他方法来执行工作？
*	舱壁模式——微服务应用程序使用多个分布式资源来执行工作。如何区分这些调用，以便表现不佳的服务调用不会对应用程序的其他部分产生负面影响？

### 1.9.4 微服务安全模式

3种基本的安全模式：

*	验证——如何确定调用服务的客户端就是它们声称的那个主体？
*	授权——如何确定调用微服务的客户端是否允许执行它们正在进行的操作？
*	凭据管理和传播——如何避免客户端每次都要提供凭据信息才能访问事务中涉及的服务调用？

### 1.9.5 微服务日志记录和跟踪模式

*	日志关联
*	日志聚合
*	微服务跟踪

### 1.9.6 微服务构建和部署模式

微服务架构的核心原则之一是，微服务的每个实例都应该和其他所有实例相同。

不可变基础设施是成功使用微服务架构的关键因素，因为在生产中必须要保证开发人员为特定微服务启动的每个微服务实例与其他微服务实例相同。

*	构建和部署管道——如何创建一个可重复的构建和部署过程，只需一键即可构建和部署到组织中的任何环境？
*	基础设施即代码——如何将服务的基础设施作为可在源代码管理下执行和管理的代码去对待？
*	不可变服务器——一旦创建了微服务镜像，如何确保它在部署之后永远不会更改？
*	凤凰服务器（Phoenix server）——服务器运行的时间越长，就越容易发生配置漂移。如何确保运行微服务的服务器定期被拆卸，并重新创建一个不可变的镜像？

使用这些模式和主题的目的是，在配置漂移影响到上层环境（如交付准备环境或生产环境）之前，尽可能快地公开并消除配置漂移。

## 1.10 使用Spring Cloud构建微服务

*	开发模式
	*	核心微服务模式Spring Boot
	*	配置管理Spring Cloud Config
	*	异步消息处理Spring Cloud Stream
*	路由模式
	*	服务发现模式Spring Cloud/Netflix Eureka
	*	服务路由模式Spring Cloud/Netflix Zuul
*	客户端弹性模式
	*	客户端负载均衡Spring Cloud/Netflix Ribbon
	*	断路器模式Spring Cloud/Netflix Hystrix
	*	后备模式Spring Cloud/Netflix Hystrix
	*	舱壁模式Spring Cloud/Netflix Hystrix
*	构建部署模式
	*	持续集成Travis CI
	*	基础设施即代码Docker
	*	不可变服务器Docker
	*	凤凰服务器Travis CI/Docker
*	日志记录模式
	*	日志关联Spring Cloud Sleuth
	*	日志聚合Spring Cloud Sleuth(与Papertrail)
	*	微服务跟踪Spring Cloud Sleuth/Zipkin
*	安全模式
	*	授权Spring Cloud Security/OAuth2
	*	验证Spring Cloud Security/OAuth2
	*	凭证管理和传播Spring Cloud Security/OAuth2/JWT
	
### 1.10.1 Spring Boot

Spring Boot是微服务实现中使用的核心技术。Spring Boot通过简化构建基于REST的微服务的核心任务，大大简化了微服务开发。Spring Boot还极大地简化了将HTTP类型的动词（GET、PUT、POST和DELETE）应到到URL、JSON协议序列化与Java对象的相互转化，以及将Java异常映射回标准HTTP错误代码的工作。

### 1.10.2 Spring Cloud Config

Spring Cloud Config通过集中式服务来处理应用程序配置数据的管理，因此应用程序配置数据（特别是环境特定的配置数据）与部署的微服务完全分离。这确保了无论启动多少个微服务实例，这些微服务实例始终具有相同的配置。Spring Cloud Config拥有自己的属性管理存储库，也可以与以下开源项目集成：

*	Git——Spring Cloud Config可以与Git支持的存储库集成，并读出存储库中的应用程序的配置数据。
*	Consul——Consul是一种开源的服务发现工具，允许服务实例向该服务注册自己。服务客户端可以向Consul咨询服务实例的位置。Consul还包括可以被Spring Cloud Config使用的基于键值存储的数据库，能够用来存储应用陈旭的配置数据。
*	Eureka——Eureka是一个开源的Netflix项目，像Consul一样，提供类似的服务发现功能。Eureka同样有一个可以被Spring Cloud Config使用的键值数据库。

### 1.10.3 Spring Cloud服务发现

通过Spring Cloud服务发现，开发人员可以从客户端消费的服务中抽象出部署服务器的物理位置（IP或服务器名称）。服务消费者通过逻辑名称而不是物理位置来调用服务器的业务逻辑。Spring Cloud服务发现也处理服务实例的注册和注销（在服务实例启动和关闭时）。Spring Cloud服务发现可以使用Consul和Eureka作为服务发现引擎。

### 1.10.4 Spring Cloud与Netflix Hystrix和Netflix Ribbon

Spring Cloud与Netflix的开源项目进行了大量整合。对于微服务客户端弹性模式，Spring Cloud封装了Netflix Hystrix库和Netflix Ribbon项目，开发人员可以轻松地在微服务中使用它们。

使用Netflix Hystrix库，开发人员可以快速实现服务客户端弹性模式，如断路器模式和舱壁模式。

虽然Netflix Ribbon项目简化了与诸如Eureka这样的服务发现代理的集成，但它也为服务消费者提供了客户端对服务调用的负载均衡。即使在服务发现代理暂时不可用时，客户端也可以继续进行服务调用。

### 1.10.5 Spring Cloud与Netflix Zuul

Spring Cloud使用Netflix Zuul项目为微服务应用程序提供服务路由功能。Zuul时代理服务请求的服务网关，确保在调用目标服务之前，对微服务的所有调用都经过一个”前门“。通过集中的服务调用，开发人员可以强制执行标准服务策略，如安全授权验证、内容过滤和路由规则。

### 1.10.6 Spring Cloud Stream

Spring Cloud Stream（https://cloud.spirng.io/spring-cloud-stream/）是一种可让开发人员轻松地将轻量级消息处理集成到微服务中的支持技术。借助Spring Cloud Stream，开发人员能够构建智能的服务，它可以使用在应用程序中出现的异步事件。此外，使用Spring Cloud Stream可以快速将微服务与消息代理进行整合，如RabbitMQ和Kafka。

### 1.10.7 Spring Cloud Sleuth

Spring Cloud Sleuth允许将唯一跟踪标识符集成到应用程序所使用的HTTP调用和消息通道（RabbitMQ、Apache Kafka）之中。这些跟踪号码（有时称为关联ID或跟踪ID）能够让开发人员在事务流经应用程序中的不同服务时跟踪事务。有了Spring Cloud Sleuth，这些跟踪ID将自动添加到微服务生成的任何日志记录中。

Spring Cloud Sleuth与日志聚合技术工具（如Papertrail）和跟踪工具（如Zipkin）结合时，能够展现出真正的威力。Papertrail是一个基于云的日志记录平台，用于将日志从不同的微服务实时聚合到一个可查询的数据库中。Zipkin可以获取Spring Cloud Sleuth生成的数据，并允许开发人员可视化单个事务涉及的微服务调用流程。

### 1.10.8 Spring Cloud Security

Spring Cloud Security是一个验证和授权框架，可以控制哪些人可以访问服务，以及他们可以用服务做什么。Spring Cloud Security是基于令牌的，允许服务通过验证服务器发出的令牌彼此进行通信。接收调用的每个服务可以检查HTTP中调用中提供的令牌，以确认用户的身份以及用户对该服务的访问权限。

此外，Spring Cloud Security支持JSON Web Token。JSON Web Token(JWT)框架标准化了创建OAuth2令牌的格式，并为创建的令牌进行数字签名提供了标准。

### 1.10.9 代码供应

要实现代码供应，我们将会转移到其他的技术栈。Spring框架是面向应用程序开发的，它（包括Spring Cloud）没有用于创建”构建和部署“管道的工具。要实现一个”构建和部署“管道，开发人员需要使用Travis CI和Docker这两样工具，前者可以作为构建工具，而后者可以构建包含微服务的服务器镜像。

## 1.11 通过示例来介绍Spring Cloud

@EnableCircuitBreaker和@EnableEurekaClient注解：

*	@EnableCircuitBreaker注解告诉Spring微服务，将要在应用程序使用Netflix Hystrix库。
*	@EnableEurekaClient注解告诉微服务使用Eureka服务发现代理去注册它自己，并且将要在代码中使用服务发现去查询远程REST服务端点。