---
layout: post
notes: true
subtitle: "高性能MySQL（第3版）"
comments: false
author: "【美】Baron Schwartz, Peter Zaitsev, Vadim Tkachenko 著（宁海元 周振兴 彭立勋 翟卫祥 等译）"
date: 2016-11-25 00:00:00

---

![](/img/notes/db/highPerformanceMySQL/high_performance_mysql.jpg)

*   目录
{:toc }

# 第1章 MySQL架构与历史

MySQL最重要、最与众不同的特性是它的存储引擎架构，这种架构的设计将查询处理（Query Processing）及其他系统任务（Server Task）和数据的存储/提取相分离。

## 1.1 MySQL逻辑架构

![](/img/notes/db/highPerformanceMySQL/logic_architect.png)

### 1.1.1 连接管理与安全性

每个客户端连接都会在服务器进程中拥有一个线程，服务器会负责缓存线程，因此不需要为每一个新建的连接创建或者销毁线程。

### 1.1.2 优化与执行

优化器并不关心表使用的是什么存储引擎，但存储引擎对于优化查询是有影响的。优化器会请求存储引擎提供容量或某个具体操作的开销信息，以及表数据的统计信息等。

## 1.2 并发控制

MySQL在两个层面的并发控制：服务器层与存储引擎层。

### 1.2.1 读写锁

*   共享锁(shared lock)：读锁(read lock)是共享的，多个客户在同一时刻可以同时读取同一个资源，而互不干扰。
*   排他锁(exclusive lock)：写锁(write lock)则是排他的，一个写锁会阻塞其他的写锁和读锁。

确保在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。

### 1.2.2 锁粒度

*   表锁(table lock)：MySQL中最基本的锁策略，并且是开销最小的策略。
*   行级锁(row lock)：行级锁可以最大程度地支持并发处理（同时也带来最大的锁开销）。行级锁只在存储引擎层实现（InnoDB、XtraDB），而MySQL服务器层没有实现。

## 1.3 事务

*   原子性(atomicity)：一个事务必须被视为一个不可分割的最小工作单元，整个事务中所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作。
*   一致性(consistency)：数据库总是从一个一致性的状态转换到另外一个一致性的状态。
*   隔离性(isolation)：通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。
*   持久性(durability)：一旦事务提交，则其所做的修改就会永久保存到数据库中。

### 1.3.1 隔离级别

*   READ UNCOMMITTED（未提交读）：事务中的修改，即使没有提交，对其他的事务也都是可见的。事务可以读取未提交的数据，这也称为脏读（Dirty Read）。
*   READ COMMITED（提交读）：大多数数据库系统的默认隔离级别都是READ COMMITTED（但MySQL不是）。一个事务开始时，只能"看见"已经提交的事务所做的修改。话句话说，一个事务从开始直到提交之前，所做的任务修改对其他事务都是不可见的。这个级别有时候也叫做不可重复读（nonrepeatable read），因为两次执行同样的查询，可能会得到不一样的结果。
*   REPEATABLE READ（可重复读）：解决了脏读问题。该级别保证了在同一个事务中多次读取同样记录的结果是一致的。但无法解决幻读（Phantom Read）问题。所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行（Phantom Row）。可重复读是MySQL的默认事务隔离级别。
*   SERIALIZABLE（可串行化）：最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读的问题。

### 1.3.2 死锁

死锁是指两个或者多个事务在同一个资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。多个事务同时锁定同一资源时，也会产生死锁。

为了解决死锁问题，数据库系统实现了各种死锁检测和死锁超时机制。

死锁发生以后，只有部分或者完全回滚其中一个事务，才能打破死锁。对于事务型的系统，这是无法避免的，所以应用程序在设计时必须考虑如何处理死锁。大多数情况下只需重新执行因死锁回滚的事务即可。

### 1.3.3 事务日志

事务日志可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把修改行为记录持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久化到磁盘。

事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O。

事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。

如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。

### 1.3.4 MySQL中的事务

MySQL提供了两种事务型的存储引擎：InnoDB和NDB Cluster。

#### 自动提交（AUTOCOMMIT）

MySQL默认采用自动提交（AUTOCOMMIT）模式。如果不是显示地开始一个事务，则每个查询都被当作一个事务执行提交操作。

    mysql> SHOW VARIABLES LIKE 'AUTOCOMMIT';
    mysql> SET AUTOCOMMIT = 1;

当AUTOCOMMIT=0时，所有的查询都是在一个事务中，直到显示地执行COMMIT提交或者ROLLBACK回滚，该事务结束，同时又开始了另一个新事物。修改AUTOCOMMIT对非事务型的表，比如MyISAM或者内存表，不会有任何影响。

MySQL可以通过执行SET TRANSACTION ISOLATION LEVEL命令来设置隔离级别。新的隔离级别会在下一个事务开始的时候生效。可以在配置文件中设置整个数据库的隔离级别，也可以只改变当前会话的隔离级别：

    mysql> SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

#### 在事务中混合使用存储引擎

在同一个事务中，使用多种存储引擎是不可靠的。

为每张表选择合适的存储引擎非常重要。

