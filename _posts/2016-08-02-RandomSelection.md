---
layout: post
title: 随机选择问题（一个胡思乱想而生的问题）
comments: true
author: "Bao Jie"
date: 2016-08-02 12:00:00
header-img: 
tags:
    - 算法
    - 随机问题
---

有一次在胡思乱想的时候抽象出来一个问题，比如你从一个地方不停的接收数据，每次收到的数据都是一个数字，对方一共会发送多少数据你不知道，但总有一天会发送完成。你的目标是从用O(1)的空间复杂度来随机选择其中的一个数字，要求每个数字被选中的概率都是一样的。

这个问题看着貌似不可能有解，开玩笑嘛，一共有多少个数都不知道，还不让我存储过多的信息，怎么随机选？

好了，不卖关子了，接下来要公布答案了（不想被剧透的不要往下看了）

既然是随机问题，那一般都会用到一个神奇的工具，叫随机数生成器。我们每读入一个数，就随机生成一个数来作为读入那个数的Tag，每次操作只保留当前值最大的Tag及它所对应的数字，最终Tag值最大的数作为我们随机选出的数。

答案简单的描述完了，一定有读者会问我，凭啥这样选出来的数是随机的？

要证明也很简单，你只要想通另一个问题就可以了：随机生成一批数，值最大的那个是随机的么？即哪个数成为最大的那个数的概率是相同的。当然也有种例外的情况，即出现了两个以上相同的最大值，这个我想只要把随机的Range拉的足够大就能避免了。

好了，这篇由胡思乱想而生的文章就写到这了，你有没有觉得很无聊呢？

文章发出后，有同事指出因为你不知道会有多少个数，所以你无法很好的选择随机数生成的Range范围，一旦不幸出现了2个以上的最大值，那么每个数被随机的概率就不同了。他说的很对，这是这个算法的致命缺点。非常幸运的是，有一位Google大神看了这篇文章后提供了一个非常牛B的算法，完美的解决了这个问题。

算法如下：当读入第N(1<=N)个数时，随机生成一个[1,N]之间随机数（整数）n，如果n=1，就用第N个数来替换当前保留的数，否则不做任何操作。因为当N=1时，生成的随机数必定是1，所以保证了当前保留的至少有一个数。

算法非常巧妙，正确性证明可以采取数学归纳法，这里就不展开了，有兴趣的读者自行证明即可。

问起那位大神怎么想到的该算法，他说曾经在工作中碰到过类似的问题，只是要比这个问题更复杂些，随机选出的是M个数，而不是1个数，空间复杂度要求O(M)。我照着他的解题思路想了想，过了会儿就霍然开朗了。读者也自己想一想吧，来体验把这个奇妙的思路吧。